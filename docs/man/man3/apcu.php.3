.TH "vendor/jetbrains/phpstorm-stubs/apcu/apcu.php" 3 "Sat Sep 26 2020" "Safaricom SDP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
vendor/jetbrains/phpstorm-stubs/apcu/apcu.php
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBAPCIterator\fP"
.br
.ti -1c
.RI "class \fBAPCUIterator\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBapc_cache_info\fP ($type='', $limited=\fBfalse\fP)"
.br
.ti -1c
.RI "\fBapc_clear_cache\fP ($cache_type='')"
.br
.ti -1c
.RI "\fBapc_sma_info\fP ($limited=\fBfalse\fP)"
.br
.ti -1c
.RI "\fBapc_store\fP ($\fBkey\fP, $var, $ttl=0)"
.br
.ti -1c
.RI "\fBapc_fetch\fP ($\fBkey\fP, &$success=\fBnull\fP)"
.br
.ti -1c
.RI "\fBapc_delete\fP ($\fBkey\fP)"
.br
.ti -1c
.RI "\fBapc_define_constants\fP ($\fBkey\fP, array $constants, $case_sensitive=\fBtrue\fP)"
.br
.ti -1c
.RI "\fBapc_add\fP ($\fBkey\fP, $var, $ttl=0)"
.br
.ti -1c
.RI "\fBapc_compile_file\fP ($filename, $atomic=\fBtrue\fP)"
.br
.ti -1c
.RI "\fBapc_load_constants\fP ($\fBkey\fP, $case_sensitive=\fBtrue\fP)"
.br
.ti -1c
.RI "\fBapc_exists\fP ($keys)"
.br
.ti -1c
.RI "\fBapc_delete_file\fP ($keys)"
.br
.ti -1c
.RI "\fBapc_inc\fP ($\fBkey\fP, $step=1, &$success=\fBnull\fP)"
.br
.ti -1c
.RI "\fBapc_dec\fP ($\fBkey\fP, $step=1, &$success=\fBnull\fP)"
.br
.ti -1c
.RI "\fBapc_cas\fP ($\fBkey\fP, $old, $new)"
.br
.ti -1c
.RI "\fBapc_bin_dump\fP ($files=\fBnull\fP, $user_vars=\fBnull\fP)"
.br
.ti -1c
.RI "\fBapc_bin_dumpfile\fP ($files, $user_vars, $filename, $flags=0, $context=\fBnull\fP)"
.br
.ti -1c
.RI "\fBapc_bin_load\fP ($data, $flags=0)"
.br
.ti -1c
.RI "\fBapc_bin_loadfile\fP ($filename, $context=\fBnull\fP, $flags=0)"
.br
.ti -1c
.RI "\fBapcu_clear_cache\fP ()"
.br
.ti -1c
.RI "\fBapcu_sma_info\fP ($limited=\fBfalse\fP)"
.br
.ti -1c
.RI "\fBapcu_store\fP ($\fBkey\fP, $var, $ttl=0)"
.br
.ti -1c
.RI "\fBapcu_fetch\fP ($\fBkey\fP, &$success=\fBnull\fP)"
.br
.ti -1c
.RI "\fBapcu_delete\fP ($\fBkey\fP)"
.br
.ti -1c
.RI "\fBapcu_add\fP ($\fBkey\fP, $var, $ttl=0)"
.br
.ti -1c
.RI "\fBapcu_exists\fP ($keys)"
.br
.ti -1c
.RI "\fBapcu_inc\fP ($\fBkey\fP, $step=1, &$success=\fBnull\fP)"
.br
.ti -1c
.RI "\fBapcu_dec\fP ($\fBkey\fP, $step=1, &$success=\fBnull\fP)"
.br
.ti -1c
.RI "\fBapcu_cas\fP ($\fBkey\fP, $old, $new)"
.br
.ti -1c
.RI "\fBapcu_entry\fP ($\fBkey\fP, callable $generator, $ttl=0)"
.br
.ti -1c
.RI "\fBapcu_cache_info\fP ($limited=\fBfalse\fP)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBAPC_BIN_VERIFY_MD5\fP 1"
.br
.ti -1c
.RI "const \fBAPC_BIN_VERIFY_CRC32\fP 2"
.br
.ti -1c
.RI "const \fBAPC_LIST_ACTIVE\fP 1"
.br
.ti -1c
.RI "const \fBAPC_LIST_DELETED\fP 2"
.br
.ti -1c
.RI "const \fBAPC_ITER_TYPE\fP 1"
.br
.ti -1c
.RI "const \fBAPC_ITER_KEY\fP 2"
.br
.ti -1c
.RI "const \fBAPC_ITER_FILENAME\fP 4"
.br
.ti -1c
.RI "const \fBAPC_ITER_DEVICE\fP 8"
.br
.ti -1c
.RI "const \fBAPC_ITER_INODE\fP 16"
.br
.ti -1c
.RI "const \fBAPC_ITER_VALUE\fP 32"
.br
.ti -1c
.RI "const \fBAPC_ITER_MD5\fP 64"
.br
.ti -1c
.RI "const \fBAPC_ITER_NUM_HITS\fP 128"
.br
.ti -1c
.RI "const \fBAPC_ITER_MTIME\fP 256"
.br
.ti -1c
.RI "const \fBAPC_ITER_CTIME\fP 512"
.br
.ti -1c
.RI "const \fBAPC_ITER_DTIME\fP 1024"
.br
.ti -1c
.RI "const \fBAPC_ITER_ATIME\fP 2048"
.br
.ti -1c
.RI "const \fBAPC_ITER_REFCOUNT\fP 4096"
.br
.ti -1c
.RI "const \fBAPC_ITER_MEM_SIZE\fP 8192"
.br
.ti -1c
.RI "const \fBAPC_ITER_TTL\fP 16384"
.br
.ti -1c
.RI "const \fBAPC_ITER_NONE\fP 0"
.br
.ti -1c
.RI "const \fBAPC_ITER_ALL\fP \-1"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "apc_add ( $key,  $var,  $ttl = \fC0\fP)"
Caches a variable in the data store, only if it's not already stored \fBstring $key Store the variable using this name\&. Keys are cache-unique, so attempting to use apc_add() to store data with a key that already exists will not overwrite the existing data, and will instead return FALSE\&. (This is the only difference between apc_add() and apc_store()\&.)  mixed $var The variable to store  int $ttl Time To Live; store var in the cache for ttl seconds\&. After the ttl has passed, the stored variable will be expunged from the cache (on the next request)\&. If no ttl is supplied (or if the ttl is 0), the value will persist until it is removed from the cache manually, or otherwise fails to exist in the cache (clear, restart, etc\&.)\&.  bool \fP
.SS "apc_bin_dump ( $files = \fC\fBnull\fP\fP,  $user_vars = \fC\fBnull\fP\fP)"
Returns a binary dump of the given files and user variables from the APC cache
.PP
\fBA\fP NULL for files or user_vars signals a dump of every entry, while array() will dump nothing\&.
.PP
\fBstring[]|null $files The files\&. Passing in NULL signals a dump of every entry, while passing in array() will dump nothing\&.  string[]|null $user_vars The user vars\&. Passing in NULL signals a dump of every entry, while passing in array() will dump nothing\&.  string|bool|null Returns a binary dump of the given files and user variables from the APC cache, FALSE if APC is not enabled, or NULL if an unknown error is encountered\&. \fP
.SS "apc_bin_dumpfile ( $files,  $user_vars,  $filename,  $flags = \fC0\fP,  $context = \fC\fBnull\fP\fP)"
Output a binary dump of the given files and user variables from the APC cache to the named file \fBstring[]|null $files The file names being dumped\&.  string[]|null $user_vars The user variables being dumped\&.  string $filename The filename where the dump is being saved\&.  int $flags Flags passed to the filename stream\&. See the file_put_contents() documentation for details\&.  resource $context The context passed to the filename stream\&. See the file_put_contents() documentation for details\&.  int|bool The number of bytes written to the file, otherwise FALSE if APC is not enabled, filename is an invalid file name, filename can't be opened, the file dump can't be completed (e\&.g\&., the hard drive is out of disk space), or an unknown error was encountered\&. \fP
.SS "apc_bin_load ( $data,  $flags = \fC0\fP)"
Load the given binary dump into the APC file/user cache \fBstring $data The binary dump being loaded, likely from apc_bin_dump()\&.  int $flags Either APC_BIN_VERIFY_CRC32, APC_BIN_VERIFY_MD5, or both\&.  bool Returns TRUE if the binary dump data was loaded with success, otherwise FALSE is returned\&. FALSE is returned if APC is not enabled, or if the data is not a valid APC binary dump (e\&.g\&., unexpected size)\&. \fP
.SS "apc_bin_loadfile ( $filename,  $context = \fC\fBnull\fP\fP,  $flags = \fC0\fP)"
Load the given binary dump from the named file into the APC file/user cache \fBstring $filename The file name containing the dump, likely from apc_bin_dumpfile()\&.  resource $context The files context\&.  int $flags Either APC_BIN_VERIFY_CRC32, APC_BIN_VERIFY_MD5, or both\&.  bool Returns TRUE on success, otherwise FALSE Reasons it may return FALSE include APC is not enabled, filename is an invalid file name or empty, filename can't be opened, the file dump can't be completed, or if the data is not a valid APC binary dump (e\&.g\&., unexpected size)\&. \fP
.SS "apc_cache_info ( $type = \fC''\fP,  $limited = \fC\fBfalse\fP\fP)"
Retrieves cached information and meta-data from APC's data store \fBstring $type If cache_type is 'user', information about the user cache will be returned\&. If cache_type is 'filehits', information about which files have been served from the bytecode cache for the current request will be returned\&. This feature must be enabled at compile time using --enable-filehits\&. If an invalid or no cache_type is specified, information about the system cache (cached files) will be returned\&.  bool $limited If limited is TRUE, the return value will exclude the individual list of cache entries\&. This is useful when trying to optimize calls for statistics gathering\&.  array|bool Array of cached data (and meta-data) or FALSE on failure\&. \fP
.SS "apc_cas ( $key,  $old,  $new)"
\fBstring $key  int $old  int $new  bool \fP
.SS "apc_clear_cache ( $cache_type = \fC''\fP)"
Clears the APC cache \fBstring $cache_type If cache_type is 'user', the user cache will be cleared; otherwise, the system cache (cached files) will be cleared\&.  bool Returns TRUE on success or FALSE on failure\&. \fP
.SS "apc_compile_file ( $filename,  $atomic = \fC\fBtrue\fP\fP)"
Stores a file in the bytecode cache, bypassing all filters \fBstring|string[] $filename Full or relative path to a PHP file that will be compiled and stored in the bytecode cache\&.  bool $atomic  bool Returns TRUE on success or FALSE on failure\&. \fP
.SS "apc_dec ( $key,  $step = \fC1\fP, & $success = \fC\fBnull\fP\fP)"
Decrease a stored number \fBstring $key The key of the value being decreased\&.  int $step The step, or value to decrease\&.  bool $success Optionally pass the success or fail boolean value to this referenced variable\&.  int|bool Returns the current value of key's value on success, or FALSE on failure\&. \fP
.SS "apc_define_constants ( $key, array $constants,  $case_sensitive = \fC\fBtrue\fP\fP)"
Defines a set of constants for retrieval and mass-definition
.PP
\fBdefine()\fP is notoriously slow\&. Since the main benefit of APC is to increase the performance of scripts/applications, this mechanism is provided to streamline the process of mass constant definition\&. However, this function does not perform as well as anticipated\&. For a better-performing solution, try the hidef extension from PECL\&.
.PP
\fBstring $key The key serves as the name of the constant set being stored\&. This key is used to retrieve the stored constants in apc_load_constants()\&.  array $constants An associative array of constant_name => value pairs\&. The constant_name must follow the normal constant naming rules\&. Value must evaluate to a scalar value\&.  bool $case_sensitive The default behaviour for constants is to be declared case-sensitive; i\&.e\&. CONSTANT and Constant represent different values\&. If this parameter evaluates to FALSE the constants will be declared as case-insensitive symbols\&.  bool Returns TRUE on success or FALSE on failure\&. \fP
.SS "apc_delete ( $key)"
Removes a stored variable from the cache \fBstring|string[]|APCIterator $key The key used to store the value (with apc_store())\&.  bool|string[] Returns TRUE on success or FALSE on failure\&. For array of keys returns list of failed keys\&. \fP
.SS "apc_delete_file ( $keys)"
Deletes the given files from the opcode cache
.PP
Accepts a string, array of strings, or \fBAPCIterator\fP object\&. Returns True/False, or for an Array an Array of failed files\&.
.PP
\fBstring|string[]|APCIterator $keys  bool|string[] \fP
.SS "apc_exists ( $keys)"
Checks if APC key exists \fBbool|string[] $keys A string, or an array of strings, that contain keys\&.  bool|string[] Returns TRUE if the key exists, otherwise FALSE Or if an array was passed to keys, then an array is returned that contains all existing keys, or an empty array if none exist\&. \fP
.SS "apc_fetch ( $key, & $success = \fC\fBnull\fP\fP)"
Fetch a stored variable from the cache \fBstring|string[] $key The key used to store the value (with apc_store())\&. If an array is passed then each element is fetched and returned\&.  bool $success Set to TRUE in success and FALSE in failure\&.  mixed The stored variable or array of variables on success; FALSE on failure\&. \fP
.SS "apc_inc ( $key,  $step = \fC1\fP, & $success = \fC\fBnull\fP\fP)"
Increase a stored number \fBstring $key The key of the value being increased\&.  int $step The step, or value to increase\&.  bool $success Optionally pass the success or fail boolean value to this referenced variable\&.  int|bool Returns the current value of key's value on success, or FALSE on failure\&. \fP
.SS "apc_load_constants ( $key,  $case_sensitive = \fC\fBtrue\fP\fP)"
Loads a set of constants from the cache \fBstring $key The name of the constant set (that was stored with apc_define_constants()) to be retrieved\&.  bool $case_sensitive The default behaviour for constants is to be declared case-sensitive; i\&.e\&. CONSTANT and Constant represent different values\&. If this parameter evaluates to FALSE the constants will be declared as case-insensitive symbols\&.  bool Returns TRUE on success or FALSE on failure\&. \fP
.SS "apc_sma_info ( $limited = \fC\fBfalse\fP\fP)"
Retrieves APC's Shared Memory Allocation information \fBbool $limited When set to FALSE (default) apc_sma_info() will return a detailed information about each segment\&.  array|bool Array of Shared Memory Allocation data; FALSE on failure\&. \fP
.SS "apc_store ( $key,  $var,  $ttl = \fC0\fP)"
Cache a variable in the data store \fBstring|array $key String: Store the variable using this name\&. Keys are cache-unique, so storing a second value with the same key will overwrite the original value\&. Array: Names in key, variables in value\&.  mixed $var [optional] The variable to store  int $ttl [optional] Time To Live; store var in the cache for ttl seconds\&. After the ttl has passed, the stored variable will be expunged from the cache (on the next request)\&. If no ttl is supplied (or if the ttl is 0), the value will persist until it is removed from the cache manually, or otherwise fails to exist in the cache (clear, restart, etc\&.)\&.  bool|array Returns TRUE on success or FALSE on failure | array with error keys\&. \fP
.SS "apcu_add ( $key,  $var,  $ttl = \fC0\fP)"
Caches a variable in the data store, only if it's not already stored \fBstring|array $key Store the variable using this name\&. Keys are cache-unique, so attempting to use apcu_add() to store data with a key that already exists will not overwrite the existing data, and will instead return FALSE\&. (This is the only difference between apcu_add() and apcu_store()\&.) Array: Names in key, variables in value\&.  mixed $var The variable to store  int $ttl Time To Live; store var in the cache for ttl seconds\&. After the ttl has passed, the stored variable will be expunged from the cache (on the next request)\&. If no ttl is supplied (or if the ttl is 0), the value will persist until it is removed from the cache manually, or otherwise fails to exist in the cache (clear, restart, etc\&.)\&.  bool|array Returns TRUE if something has effectively been added into the cache, FALSE otherwise\&. Second syntax returns array with error keys\&. \fP
.SS "apcu_cache_info ( $limited = \fC\fBfalse\fP\fP)"
Retrieves cached information from APCu's data store
.PP
\fBbool $limited If limited is TRUE, the return value will exclude the individual list of cache entries\&. This is useful when trying to optimize calls for statistics gathering\&.  array|false Array of cached data (and meta-data) or FALSE on failure \fP
.SS "apcu_cas ( $key,  $old,  $new)"
Updates an old value with a new value
.PP
\fBapcu_cas()\fP updates an already existing integer value if the old parameter matches the currently stored value with the value of the new parameter\&.
.PP
\fBstring $key The key of the value being updated\&.  int $old The old value (the value currently stored)\&.  int $new The new value to update to\&.  bool Returns TRUE on success or FALSE on failure\&. \fP
.SS "apcu_clear_cache ()"
Clears the APCu cache \fBbool Returns TRUE always\&. \fP
.SS "apcu_dec ( $key,  $step = \fC1\fP, & $success = \fC\fBnull\fP\fP)"
Decrease a stored number \fBstring $key The key of the value being decreased\&.  int $step The step, or value to decrease\&.  bool $success Optionally pass the success or fail boolean value to this referenced variable\&.  int|false Returns the current value of key's value on success, or FALSE on failure\&. \fP
.SS "apcu_delete ( $key)"
Removes a stored variable from the cache \fBstring|string[]|APCUIterator $key The key used to store the value (with apcu_store())\&.  bool|string[] Returns TRUE on success or FALSE on failure\&. For array of keys returns list of failed keys\&. \fP
.SS "apcu_entry ( $key, callable $generator,  $ttl = \fC0\fP)"
Atomically fetch or generate a cache entry
.PP
Atomically attempts to find key in the cache, if it cannot be found generator is called, passing key as the only argument\&. The return value of the call is then cached with the optionally specified ttl, and returned\&. 
.PP
Note: When control enters \fI\fBapcu_entry()\fP\fP the lock for the cache is acquired exclusively, it is released when control leaves \fBapcu_entry()\fP: In effect, this turns the body of generator into a critical section, disallowing two processes from executing the same code paths concurrently\&. In addition, it prohibits the concurrent execution of any other APCu functions, since they will acquire the same lock\&. 
.PP
\fBstring $key Identity of cache entry  callable $generator A callable that accepts key as the only argument and returns the value to cache\&. \fPWarning The only APCu function that can be called safely by generator is \fBapcu_entry()\fP\&.
.PP
\fBParameters\fP
.RS 4
\fI$ttl\fP [optional] Time To Live; store var in the cache for ttl seconds\&. After the ttl has passed, the stored variable will be expunged from the cache (on the next request)\&. If no ttl is supplied (or if the ttl is 0), the value will persist until it is removed from the cache manually, or otherwise fails to exist in the cache (clear, restart, etc\&.)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
mixed Returns the cached value 
.RE
.PP
\fBSince\fP
.RS 4
APCu 5\&.1\&.0 
.RE
.PP

.SS "apcu_exists ( $keys)"
Checks if APCu key exists \fBstring|string[] $keys A string, or an array of strings, that contain keys\&.  bool|string[] Returns TRUE if the key exists, otherwise FALSE Or if an array was passed to keys, then an array is returned that contains all existing keys, or an empty array if none exist\&. \fP
.SS "apcu_fetch ( $key, & $success = \fC\fBnull\fP\fP)"
Fetch a stored variable from the cache \fBstring|string[] $key The key used to store the value (with apcu_store())\&. If an array is passed then each element is fetched and returned\&.  bool $success Set to TRUE in success and FALSE in failure\&.  mixed The stored variable or array of variables on success; FALSE on failure\&. \fP
.SS "apcu_inc ( $key,  $step = \fC1\fP, & $success = \fC\fBnull\fP\fP)"
Increase a stored number \fBstring $key The key of the value being increased\&.  int $step The step, or value to increase\&.  bool $success Optionally pass the success or fail boolean value to this referenced variable\&.  int|false Returns the current value of key's value on success, or FALSE on failure\&. \fP
.SS "apcu_sma_info ( $limited = \fC\fBfalse\fP\fP)"
Retrieves APCu Shared Memory Allocation information \fBbool $limited When set to FALSE (default) apcu_sma_info() will return a detailed information about each segment\&.  array|false Array of Shared Memory Allocation data; FALSE on failure\&. \fP
.SS "apcu_store ( $key,  $var,  $ttl = \fC0\fP)"
Cache a variable in the data store \fBstring|array $key String: Store the variable using this name\&. Keys are cache-unique, so storing a second value with the same key will overwrite the original value\&. Array: Names in key, variables in value\&.  mixed $var [optional] The variable to store  int $ttl [optional] Time To Live; store var in the cache for ttl seconds\&. After the ttl has passed, the stored variable will be expunged from the cache (on the next request)\&. If no ttl is supplied (or if the ttl is 0), the value will persist until it is removed from the cache manually, or otherwise fails to exist in the cache (clear, restart, etc\&.)\&.  bool|array Returns TRUE on success or FALSE on failure | array with error keys\&. \fP
.SH "Variable Documentation"
.PP 
.SS "const APC_BIN_VERIFY_CRC32 2"
\fBhttps://php\&.net/manual/en/apc\&.constants\&.php\fP
.SS "const APC_BIN_VERIFY_MD5 1"
Stubs for APC (apcu_bc nowadays) extension \fBhttps://php\&.net/manual/en/apc\&.constants\&.php\fP
.SS "const APC_ITER_ALL \-1"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_ATIME 2048"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_CTIME 512"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_DEVICE 8"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_DTIME 1024"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_FILENAME 4"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_INODE 16"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_KEY 2"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_MD5 64"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_MEM_SIZE 8192"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_MTIME 256"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_NONE 0"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_NUM_HITS 128"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_REFCOUNT 4096"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_TTL 16384"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_TYPE 1"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_ITER_VALUE 32"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_LIST_ACTIVE 1"
Stubs for APCu 5\&.0\&.0 \fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SS "const APC_LIST_DELETED 2"
\fBhttps://php\&.net/manual/en/apcu\&.constants\&.php\fP
.SH "Author"
.PP 
Generated automatically by Doxygen for Safaricom SDP from the source code\&.
