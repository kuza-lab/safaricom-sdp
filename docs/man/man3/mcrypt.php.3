.TH "vendor/jetbrains/phpstorm-stubs/mcrypt/mcrypt.php" 3 "Sat Sep 26 2020" "Safaricom SDP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
vendor/jetbrains/phpstorm-stubs/mcrypt/mcrypt.php
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBmcrypt_ecb\fP ($cipher, $\fBkey\fP, $data, $mode)"
.br
.ti -1c
.RI "\fBmcrypt_cbc\fP ($cipher, $\fBkey\fP, $data, $mode, $iv=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_cfb\fP ($cipher, $\fBkey\fP, $data, $mode, $iv=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_ofb\fP ($cipher, $\fBkey\fP, $data, $mode, $iv=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_get_key_size\fP ($cipher, $mode)"
.br
.ti -1c
.RI "\fBmcrypt_get_block_size\fP ($cipher, $mode)"
.br
.ti -1c
.RI "\fBmcrypt_get_cipher_name\fP ($cipher)"
.br
.ti -1c
.RI "\fBmcrypt_create_iv\fP ($size, $source=\fBMCRYPT_DEV_URANDOM\fP)"
.br
.ti -1c
.RI "\fBmcrypt_list_algorithms\fP ($lib_dir=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_list_modes\fP ($lib_dir=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_get_iv_size\fP ($cipher, $mode)"
.br
.ti -1c
.RI "\fBmcrypt_encrypt\fP ($cipher, $\fBkey\fP, $data, $mode, $iv=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_decrypt\fP ($cipher, $\fBkey\fP, $data, $mode, $iv=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_module_open\fP ($algorithm, $algorithm_directory, $mode, $mode_directory)"
.br
.ti -1c
.RI "\fBmcrypt_generic_init\fP ($td, $\fBkey\fP, $iv)"
.br
.ti -1c
.RI "\fBmcrypt_generic\fP ($td, $data)"
.br
.ti -1c
.RI "\fBmdecrypt_generic\fP ($td, $data)"
.br
.ti -1c
.RI "\fBmcrypt_generic_end\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_generic_deinit\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_enc_self_test\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_enc_is_block_algorithm_mode\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_enc_is_block_algorithm\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_enc_is_block_mode\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_enc_get_block_size\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_enc_get_key_size\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_enc_get_supported_key_sizes\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_enc_get_iv_size\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_enc_get_algorithms_name\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_enc_get_modes_name\fP ($td)"
.br
.ti -1c
.RI "\fBmcrypt_module_self_test\fP ($algorithm, $lib_dir=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_module_is_block_algorithm_mode\fP ($mode, $lib_dir=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_module_is_block_algorithm\fP ($algorithm, $lib_dir=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_module_is_block_mode\fP ($mode, $lib_dir=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_module_get_algo_block_size\fP ($algorithm, $lib_dir=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_module_get_algo_key_size\fP ($algorithm, $lib_dir=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_module_get_supported_key_sizes\fP ($algorithm, $lib_dir=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmcrypt_module_close\fP ($td)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBMCRYPT_ENCRYPT\fP 0"
.br
.ti -1c
.RI "const \fBMCRYPT_DECRYPT\fP 1"
.br
.ti -1c
.RI "const \fBMCRYPT_DEV_RANDOM\fP 0"
.br
.ti -1c
.RI "const \fBMCRYPT_DEV_URANDOM\fP 1"
.br
.ti -1c
.RI "const \fBMCRYPT_RAND\fP 2"
.br
.ti -1c
.RI "const \fBMCRYPT_3DES\fP 'tripledes'"
.br
.ti -1c
.RI "const \fBMCRYPT_ARCFOUR_IV\fP 'arcfour\-iv'"
.br
.ti -1c
.RI "const \fBMCRYPT_ARCFOUR\fP 'arcfour'"
.br
.ti -1c
.RI "const \fBMCRYPT_BLOWFISH\fP 'blowfish'"
.br
.ti -1c
.RI "const \fBMCRYPT_BLOWFISH_COMPAT\fP 'blowfish\-compat'"
.br
.ti -1c
.RI "const \fBMCRYPT_CAST_128\fP 'cast\-128'"
.br
.ti -1c
.RI "const \fBMCRYPT_CAST_256\fP 'cast\-256'"
.br
.ti -1c
.RI "const \fBMCRYPT_CRYPT\fP 'crypt'"
.br
.ti -1c
.RI "const \fBMCRYPT_DES\fP 'des'"
.br
.ti -1c
.RI "const \fBMCRYPT_ENIGNA\fP 'crypt'"
.br
.ti -1c
.RI "const \fBMCRYPT_GOST\fP 'gost'"
.br
.ti -1c
.RI "const \fBMCRYPT_LOKI97\fP 'loki97'"
.br
.ti -1c
.RI "const \fBMCRYPT_PANAMA\fP 'panama'"
.br
.ti -1c
.RI "const \fBMCRYPT_RC2\fP 'rc2'"
.br
.ti -1c
.RI "const \fBMCRYPT_RIJNDAEL_128\fP 'rijndael\-128'"
.br
.ti -1c
.RI "const \fBMCRYPT_RIJNDAEL_192\fP 'rijndael\-192'"
.br
.ti -1c
.RI "const \fBMCRYPT_RIJNDAEL_256\fP 'rijndael\-256'"
.br
.ti -1c
.RI "const \fBMCRYPT_SAFER64\fP 'safer\-sk64'"
.br
.ti -1c
.RI "const \fBMCRYPT_SAFER128\fP 'safer\-sk128'"
.br
.ti -1c
.RI "const \fBMCRYPT_SAFERPLUS\fP 'saferplus'"
.br
.ti -1c
.RI "const \fBMCRYPT_SERPENT\fP 'serpent'"
.br
.ti -1c
.RI "const \fBMCRYPT_THREEWAY\fP 'threeway'"
.br
.ti -1c
.RI "const \fBMCRYPT_TRIPLEDES\fP 'tripledes'"
.br
.ti -1c
.RI "const \fBMCRYPT_TWOFISH\fP 'twofish'"
.br
.ti -1c
.RI "const \fBMCRYPT_WAKE\fP 'wake'"
.br
.ti -1c
.RI "const \fBMCRYPT_XTEA\fP 'xtea'"
.br
.ti -1c
.RI "const \fBMCRYPT_IDEA\fP 'idea'"
.br
.ti -1c
.RI "const \fBMCRYPT_MARS\fP 'mars'"
.br
.ti -1c
.RI "const \fBMCRYPT_RC6\fP 'rc6'"
.br
.ti -1c
.RI "const \fBMCRYPT_SKIPJACK\fP 'skipjack'"
.br
.ti -1c
.RI "const \fBMCRYPT_MODE_CBC\fP 'cbc'"
.br
.ti -1c
.RI "const \fBMCRYPT_MODE_CFB\fP 'cfb'"
.br
.ti -1c
.RI "const \fBMCRYPT_MODE_ECB\fP 'ecb'"
.br
.ti -1c
.RI "const \fBMCRYPT_MODE_NOFB\fP 'nofb'"
.br
.ti -1c
.RI "const \fBMCRYPT_MODE_OFB\fP 'ofb'"
.br
.ti -1c
.RI "const \fBMCRYPT_MODE_STREAM\fP 'stream'"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "mcrypt_cbc ( $cipher,  $key,  $data,  $mode,  $iv = \fC\fBnull\fP\fP)"
Encrypt/decrypt data in CBC mode \fBdeprecated 77\&. int|string $cipher  string $key  string $data  int $mode  string $iv [optional]  string  4\&.0  5\&.0 \fP
.SS "mcrypt_cfb ( $cipher,  $key,  $data,  $mode,  $iv = \fC\fBnull\fP\fP)"
Encrypt/decrypt data in CFB mode \fBdeprecated 78\&. int|string $cipher  string $key  string $data  int $mode  string $iv [optional]  string  4\&.0  5\&.0 \fP
.SS "mcrypt_create_iv ( $size,  $source = \fC\fBMCRYPT_DEV_URANDOM\fP\fP)"
Create an initialization vector (IV) from a random source \fBint $size \fP Determines the size of the IV, parameter source (defaults to random value) specifies the source of the IV\&. 
.PP
\fBParameters\fP
.RS 4
\fI$source\fP [optional] 
.RE
.PP
The source can be MCRYPT_RAND (system random number generator), MCRYPT_DEV_RANDOM (read data from /dev/random) and MCRYPT_DEV_URANDOM (read data from /dev/urandom)\&. MCRYPT_RAND is the only one supported on Windows because Windows (of course) doesn't have /dev/random or /dev/urandom\&. 
.PP
When using MCRYPT_RAND, remember to call srand before mcrypt_create_iv to initialize the random number generator; it is not seeded automatically like rand is\&. 
.PP
\fBReturns\fP
.RS 4
string|false the initialization vector, or false on error\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_decrypt ( $cipher,  $key,  $data,  $mode,  $iv = \fC\fBnull\fP\fP)"
Decrypts crypttext with given parameters \fBstring $cipher \fP cipher is one of the MCRYPT_ciphername constants of the name of the algorithm as string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$key\fP 
.RE
.PP
key is the key with which the data is encrypted\&. If it's smaller that the required keysize, it is padded with '\\0'\&. 
.PP
\fBParameters\fP
.RS 4
\fI$data\fP 
.RE
.PP
data is the data that will be decrypted with the given cipher and mode\&. If the size of the data is not n * blocksize, the data will be padded with '\\0'\&. 
.PP
\fBParameters\fP
.RS 4
\fI$mode\fP 
.RE
.PP
mode is one of the MCRYPT_MODE_modename constants of one of 'ecb', 'cbc', 'cfb', 'ofb', 'nofb' or 'stream'\&. 
.PP
\fBParameters\fP
.RS 4
\fI$iv\fP [optional] 
.RE
.PP
The iv parameter is used for the initialisation in CBC, CFB, OFB modes, and in some algorithms in STREAM mode\&. If you do not supply an IV, while it is needed for an algorithm, the function issues a warning and uses an IV with all bytes set to '\\0'\&. 
.PP
\fBReturns\fP
.RS 4
string the decrypted data as a string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_ecb ( $cipher,  $key,  $data,  $mode)"
Deprecated: Encrypt/decrypt data in ECB mode \fBdeprecated 76\&. string|int $cipher  string $key  string $data  int $mode  string  4\&.0  5\&.0 \fP
.SS "mcrypt_enc_get_algorithms_name ( $td)"
Returns the name of the opened algorithm \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
string the name of the opened algorithm as a string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_enc_get_block_size ( $td)"
Returns the blocksize of the opened algorithm \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
int the block size of the specified algorithm in bytes\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_enc_get_iv_size ( $td)"
Returns the size of the IV of the opened algorithm \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
int the size of the IV, or 0 if the IV is ignored in the algorithm\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_enc_get_key_size ( $td)"
Returns the maximum supported keysize of the opened mode \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
int the maximum supported key size of the algorithm in bytes\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_enc_get_modes_name ( $td)"
Returns the name of the opened mode \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
string the name as a string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_enc_get_supported_key_sizes ( $td)"
Returns an array with the supported keysizes of the opened algorithm \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
array an array with the key sizes supported by the algorithm specified by the encryption descriptor\&. If it returns an empty array then all key sizes between 1 and mcrypt_enc_get_key_size are supported by the algorithm\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_enc_is_block_algorithm ( $td)"
Checks whether the algorithm of the opened mode is a block algorithm \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
bool true if the algorithm is a block algorithm or false if it is a stream one\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_enc_is_block_algorithm_mode ( $td)"
Checks whether the encryption of the opened mode works on blocks \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
bool true if the mode is for use with block algorithms, otherwise it returns false\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_enc_is_block_mode ( $td)"
Checks whether the opened mode outputs blocks \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
bool true if the mode outputs blocks of bytes or false if it outputs bytes\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_enc_self_test ( $td)"
Runs a self test on the opened module \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
int|bool If the self test succeeds it returns false\&. In case of an error, it returns true\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_encrypt ( $cipher,  $key,  $data,  $mode,  $iv = \fC\fBnull\fP\fP)"
Encrypts plaintext with given parameters \fBstring $cipher \fP One of the MCRYPT_ciphername constants of the name of the algorithm as string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$key\fP 
.RE
.PP
The key with which the data will be encrypted\&. If it's smaller that the required keysize, it is padded with '\\0'\&. It is better not to use ASCII strings for keys\&. 
.PP
It is recommended to use the mhash functions to create a key from a string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$data\fP 
.RE
.PP
The data that will be encrypted with the given cipher and mode\&. If the size of the data is not n * blocksize, the data will be padded with '\\0'\&. 
.PP
The returned crypttext can be larger that the size of the data that is given by data\&. 
.PP
\fBParameters\fP
.RS 4
\fI$mode\fP 
.RE
.PP
One of the MCRYPT_MODE_modename constants of one of 'ecb', 'cbc', 'cfb', 'ofb', 'nofb' or 'stream'\&. 
.PP
\fBParameters\fP
.RS 4
\fI$iv\fP [optional] 
.RE
.PP
Used for the initialisation in CBC, CFB, OFB modes, and in some algorithms in STREAM mode\&. If you do not supply an IV, while it is needed for an algorithm, the function issues a warning and uses an IV with all bytes set to '\\0'\&. 
.PP
\fBReturns\fP
.RS 4
string the encrypted data, as a string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_generic ( $td,  $data)"
This function encrypts data \fBresource $td \fP The encryption descriptor\&. 
.PP
The encryption handle should always be initialized with mcrypt_generic_init with a key and an IV before calling this function\&. Where the encryption is done, you should free the encryption buffers by calling mcrypt_generic_deinit\&. See mcrypt_module_open for an example\&. 
.PP
\fBParameters\fP
.RS 4
\fI$data\fP 
.RE
.PP
The data to encrypt\&. 
.PP
\fBReturns\fP
.RS 4
string the encrypted data\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_generic_deinit ( $td)"
This function deinitializes an encryption module \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.7 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_generic_end ( $td)"
This function terminates encryption \fBresource $td  bool  deprecated 93\&. 4\&.0\&.2  5\&.1\&.6 \fP
.SS "mcrypt_generic_init ( $td,  $key,  $iv)"
This function initializes all buffers needed for encryption \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBParameters\fP
.RS 4
\fI$key\fP 
.RE
.PP
The maximum length of the key should be the one obtained by calling mcrypt_enc_get_key_size and every value smaller than this is legal\&. 
.PP
\fBParameters\fP
.RS 4
\fI$iv\fP 
.RE
.PP
The IV should normally have the size of the algorithms block size, but you must obtain the size by calling mcrypt_enc_get_iv_size\&. IV is ignored in ECB\&. IV MUST exist in CFB, CBC, STREAM, nOFB and OFB modes\&. It needs to be random and unique (but not secret)\&. The same IV must be used for encryption/decryption\&. If you do not want to use it you should set it to zeros, but this is not recommended\&. 
.PP
\fBReturns\fP
.RS 4
int|false The function returns a negative value on error, -3 when the key length was incorrect, -4 when there was a memory allocation problem and any other return value is an unknown error\&. If an error occurs a warning will be displayed accordingly\&. false is returned if incorrect parameters were passed\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_get_block_size ( $cipher,  $mode)"
Get the block size of the specified cipher \fBstring|int $cipher \fP One of the MCRYPT_ciphername constants or the name of the algorithm as string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$mode\fP 
.RE
.PP
One of the \fBMCRYPT_MODE_modename\fP constants, or one of the following strings: 'ecb', 'cbc', 'cfb', 'ofb', 'nofb' or 'stream'\&.
.PP
\fBReturns\fP
.RS 4
int Gets the block size, as an integer\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_get_cipher_name ( $cipher)"
Get the name of the specified cipher \fBint|string $cipher \fP One of the MCRYPT_ciphername constants or the name of the algorithm as string\&. 
.PP
\fBReturns\fP
.RS 4
string|false This function returns the name of the cipher or false, if the cipher does not exist\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_get_iv_size ( $cipher,  $mode)"
Returns the size of the IV belonging to a specific cipher/mode combination \fBstring $cipher \fP One of the MCRYPT_ciphername constants of the name of the algorithm as string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$mode\fP 
.RE
.PP
mode is one of the MCRYPT_MODE_modename constants or one of 'ecb', 'cbc', 'cfb', 'ofb', 'nofb' or 'stream'\&. The IV is ignored in ECB mode as this mode does not require it\&. You will need to have the same IV (think: starting point) both at encryption and decryption stages, otherwise your encryption will fail\&. 
.PP
\fBReturns\fP
.RS 4
int|false the size of the Initialisation Vector (IV) in bytes\&. On error the function returns false\&. If the IV is ignored in the specified cipher/mode combination zero is returned\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_get_key_size ( $cipher,  $mode)"
Get the key size of the specified cipher \fBint|string $cipher  string $mode  int  4\&.0  5\&.0  deprecated 80\&. \fP
.SS "mcrypt_list_algorithms ( $lib_dir = \fC\fBnull\fP\fP)"
Get an array of all supported ciphers \fBstring $lib_dir [optional] \fP Specifies the directory where all algorithms are located\&. If not specifies, the value of the mcrypt\&.algorithms_dir &php\&.ini; directive is used\&. 
.PP
\fBReturns\fP
.RS 4
array an array with all the supported algorithms\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_list_modes ( $lib_dir = \fC\fBnull\fP\fP)"
Get an array of all supported modes \fBstring $lib_dir [optional] \fP Specifies the directory where all modes are located\&. If not specifies, the value of the mcrypt\&.modes_dir &php\&.ini; directive is used\&. 
.PP
\fBReturns\fP
.RS 4
array an array with all the supported modes\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_module_close ( $td)"
Close the mcrypt module \fBresource $td \fP The encryption descriptor\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_module_get_algo_block_size ( $algorithm,  $lib_dir = \fC\fBnull\fP\fP)"
Returns the blocksize of the specified algorithm \fBstring $algorithm \fP The algorithm name\&. 
.PP
\fBParameters\fP
.RS 4
\fI$lib_dir\fP [optional] 
.RE
.PP
This optional parameter can contain the location where the mode module is on the system\&. 
.PP
\fBReturns\fP
.RS 4
int the block size of the algorithm specified in bytes\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_module_get_algo_key_size ( $algorithm,  $lib_dir = \fC\fBnull\fP\fP)"
Returns the maximum supported keysize of the opened mode \fBstring $algorithm \fP The algorithm name\&. 
.PP
\fBParameters\fP
.RS 4
\fI$lib_dir\fP [optional] 
.RE
.PP
This optional parameter can contain the location where the mode module is on the system\&. 
.PP
\fBReturns\fP
.RS 4
int This function returns the maximum supported key size of the algorithm specified in bytes\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_module_get_supported_key_sizes ( $algorithm,  $lib_dir = \fC\fBnull\fP\fP)"
Returns an array with the supported keysizes of the opened algorithm \fBstring $algorithm \fP The algorithm to used\&. 
.PP
\fBParameters\fP
.RS 4
\fI$lib_dir\fP [optional] 
.RE
.PP
The optional lib_dir parameter can contain the location of where the algorithm module is on the system\&. 
.PP
\fBReturns\fP
.RS 4
array an array with the key sizes supported by the specified algorithm\&. If it returns an empty array then all key sizes between 1 and mcrypt_module_get_algo_key_size are supported by the algorithm\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_module_is_block_algorithm ( $algorithm,  $lib_dir = \fC\fBnull\fP\fP)"
This function checks whether the specified algorithm is a block algorithm \fBstring $algorithm \fP The algorithm to check\&. 
.PP
\fBParameters\fP
.RS 4
\fI$lib_dir\fP [optional] 
.RE
.PP
The optional lib_dir parameter can contain the location of where the algorithm module is on the system\&. 
.PP
\fBReturns\fP
.RS 4
bool This function returns true if the specified algorithm is a block algorithm, or false is it is a stream algorithm\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_module_is_block_algorithm_mode ( $mode,  $lib_dir = \fC\fBnull\fP\fP)"
Returns if the specified module is a block algorithm or not \fBstring $mode \fP The mode to check\&. 
.PP
\fBParameters\fP
.RS 4
\fI$lib_dir\fP [optional] 
.RE
.PP
The optional lib_dir parameter can contain the location of where the algorithm module is on the system\&. 
.PP
\fBReturns\fP
.RS 4
bool This function returns true if the mode is for use with block algorithms, otherwise it returns false\&. (e\&.g\&. false for stream, and true for cbc, cfb, ofb)\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_module_is_block_mode ( $mode,  $lib_dir = \fC\fBnull\fP\fP)"
Returns if the specified mode outputs blocks or not \fBstring $mode \fP The mode to check\&. 
.PP
\fBParameters\fP
.RS 4
\fI$lib_dir\fP [optional] 
.RE
.PP
The optional lib_dir parameter can contain the location of where the algorithm module is on the system\&. 
.PP
\fBReturns\fP
.RS 4
bool This function returns true if the mode outputs blocks of bytes or false if it outputs just bytes\&. (e\&.g\&. true for cbc and ecb, and false for cfb and stream)\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_module_open ( $algorithm,  $algorithm_directory,  $mode,  $mode_directory)"
Opens the module of the algorithm and the mode to be used \fBstring $algorithm \fP The algorithm to be used\&. 
.PP
\fBParameters\fP
.RS 4
\fI$algorithm_directory\fP 
.RE
.PP
The algorithm_directory and mode_directory are used to locate the encryption modules\&. When you supply a directory name, it is used\&. When you set one of these to the empty string (''), the value set by the mcrypt\&.algorithms_dir or mcrypt\&.modes_dir ini-directive is used\&. When these are not set, the default directories that are used are the ones that were compiled in into libmcrypt (usually /usr/local/lib/libmcrypt)\&. 
.PP
\fBParameters\fP
.RS 4
\fI$mode\fP 
.RE
.PP
The mode to be used\&. 
.PP
\fBParameters\fP
.RS 4
\fI$mode_directory\fP 
.RE
.PP
.PP
\fBReturns\fP
.RS 4
resource|false Normally it returns an encryption descriptor, or false on error\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_module_self_test ( $algorithm,  $lib_dir = \fC\fBnull\fP\fP)"
This function runs a self test on the specified module \fBstring $algorithm \fP One of the \fBMCRYPT_ciphername\fP constants, or the name of the algorithm as string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$lib_dir\fP [optional] 
.RE
.PP
The optional lib_dir parameter can contain the location of where the algorithm module is on the system\&. 
.PP
\fBReturns\fP
.RS 4
bool The function returns true if the self test succeeds, or false when if fails\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SS "mcrypt_ofb ( $cipher,  $key,  $data,  $mode,  $iv = \fC\fBnull\fP\fP)"
Encrypt/decrypt data in OFB mode \fBdeprecated 79\&. int|string $cipher  string $key  string $data  int $mode  string $iv [optional]  string  4\&.0  5\&.0 \fP
.SS "mdecrypt_generic ( $td,  $data)"
Decrypt data \fBresource $td \fP An encryption descriptor returned by mcrypt_module_open 
.PP
\fBParameters\fP
.RS 4
\fI$data\fP 
.RE
.PP
Encrypted data\&. 
.PP
\fBReturns\fP
.RS 4
string 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.2 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.1 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "const MCRYPT_3DES 'tripledes'"

.SS "const MCRYPT_ARCFOUR 'arcfour'"

.SS "const MCRYPT_ARCFOUR_IV 'arcfour\-iv'"

.SS "const MCRYPT_BLOWFISH 'blowfish'"

.SS "const MCRYPT_BLOWFISH_COMPAT 'blowfish\-compat'"

.SS "const MCRYPT_CAST_128 'cast\-128'"

.SS "const MCRYPT_CAST_256 'cast\-256'"

.SS "const MCRYPT_CRYPT 'crypt'"

.SS "const MCRYPT_DECRYPT 1"

.SS "const MCRYPT_DES 'des'"

.SS "const MCRYPT_DEV_RANDOM 0"

.SS "const MCRYPT_DEV_URANDOM 1"

.SS "const MCRYPT_ENCRYPT 0"

.SS "const MCRYPT_ENIGNA 'crypt'"

.SS "const MCRYPT_GOST 'gost'"

.SS "const MCRYPT_IDEA 'idea'"

.SS "const MCRYPT_LOKI97 'loki97'"

.SS "const MCRYPT_MARS 'mars'"

.SS "const MCRYPT_MODE_CBC 'cbc'"

.SS "const MCRYPT_MODE_CFB 'cfb'"

.SS "const MCRYPT_MODE_ECB 'ecb'"

.SS "const MCRYPT_MODE_NOFB 'nofb'"

.SS "const MCRYPT_MODE_OFB 'ofb'"

.SS "const MCRYPT_MODE_STREAM 'stream'"

.SS "const MCRYPT_PANAMA 'panama'"

.SS "const MCRYPT_RAND 2"

.SS "const MCRYPT_RC2 'rc2'"

.SS "const MCRYPT_RC6 'rc6'"

.SS "const MCRYPT_RIJNDAEL_128 'rijndael\-128'"

.SS "const MCRYPT_RIJNDAEL_192 'rijndael\-192'"

.SS "const MCRYPT_RIJNDAEL_256 'rijndael\-256'"

.SS "const MCRYPT_SAFER128 'safer\-sk128'"

.SS "const MCRYPT_SAFER64 'safer\-sk64'"

.SS "const MCRYPT_SAFERPLUS 'saferplus'"

.SS "const MCRYPT_SERPENT 'serpent'"

.SS "const MCRYPT_SKIPJACK 'skipjack'"

.SS "const MCRYPT_THREEWAY 'threeway'"

.SS "const MCRYPT_TRIPLEDES 'tripledes'"

.SS "const MCRYPT_TWOFISH 'twofish'"

.SS "const MCRYPT_WAKE 'wake'"

.SS "const MCRYPT_XTEA 'xtea'"

.SH "Author"
.PP 
Generated automatically by Doxygen for Safaricom SDP from the source code\&.
