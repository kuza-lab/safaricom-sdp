.TH "vendor/jetbrains/phpstorm-stubs/standard/standard_9.php" 3 "Sat Sep 26 2020" "Safaricom SDP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
vendor/jetbrains/phpstorm-stubs/standard/standard_9.php
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBAssertionError\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBarray_merge_recursive\fP (array $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_replace\fP (array $array, array $array1, array $array2=\fBnull\fP, array $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_replace_recursive\fP (array $array, array $array1, array $array2=\fBnull\fP, array $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_keys\fP (array $input, $search_value=\fBnull\fP, $strict=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_values\fP (array $input)"
.br
.ti -1c
.RI "\fBarray_count_values\fP (array $input)"
.br
.ti -1c
.RI "\fBarray_column\fP (array $array, $column, $index_key=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_reverse\fP (array $array, $preserve_keys=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_reduce\fP (array $input, $\fBfunction\fP, $initial=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_pad\fP (array $input, $pad_size, $pad_value)"
.br
.ti -1c
.RI "\fBarray_flip\fP (array $array)"
.br
.ti -1c
.RI "\fBarray_change_key_case\fP (array $input, $case=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_rand\fP (array $input, $num_req=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_unique\fP (array $array, $sort_flags=\fBSORT_STRING\fP)"
.br
.ti -1c
.RI "\fBarray_intersect\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_intersect_key\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_intersect_ukey\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP, $key_compare_func)"
.br
.ti -1c
.RI "\fBarray_uintersect\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP, $data_compare_func)"
.br
.ti -1c
.RI "\fBarray_intersect_assoc\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_uintersect_assoc\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP, $data_compare_func)"
.br
.ti -1c
.RI "\fBarray_intersect_uassoc\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP, $key_compare_func)"
.br
.ti -1c
.RI "\fBarray_uintersect_uassoc\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP, $data_compare_func, $key_compare_func)"
.br
.ti -1c
.RI "\fBarray_diff\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_diff_key\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_diff_ukey\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP, $key_compare_func)"
.br
.ti -1c
.RI "\fBarray_udiff\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP, $data_compare_func)"
.br
.ti -1c
.RI "\fBarray_diff_assoc\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_udiff_assoc\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP, $data_compare_func)"
.br
.ti -1c
.RI "\fBarray_diff_uassoc\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP, $key_compare_func)"
.br
.ti -1c
.RI "\fBarray_udiff_uassoc\fP (array $array1, array $array2, array $\fB_\fP=\fBnull\fP, $data_compare_func, $key_compare_func)"
.br
.ti -1c
.RI "\fBarray_sum\fP (array $array)"
.br
.ti -1c
.RI "\fBarray_product\fP (array $array)"
.br
.ti -1c
.RI "\fBarray_filter\fP (array $input, $\fBcallback\fP=\fBnull\fP, $flag=0)"
.br
.ti -1c
.RI "\fBarray_map\fP ($\fBcallback\fP, array $arr1, array $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_chunk\fP (array $input, $size, $preserve_keys=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_combine\fP (array $keys, array $values)"
.br
.ti -1c
.RI "\fBarray_key_exists\fP ($\fBkey\fP, array $search)"
.br
.ti -1c
.RI "\fBarray_key_first\fP (array $array)"
.br
.ti -1c
.RI "\fBarray_key_last\fP (array $array)"
.br
.ti -1c
.RI "\fBpos\fP (&$arg)"
.br
.ti -1c
.RI "\fBsizeof\fP ($var, $mode=\fBCOUNT_NORMAL\fP)"
.br
.ti -1c
.RI "\fBkey_exists\fP ($\fBkey\fP, $search)"
.br
.ti -1c
.RI "\fBassert\fP ($assertion, $description='')"
.br
.ti -1c
.RI "\fBassert_options\fP ($what, $value=\fBnull\fP)"
.br
.ti -1c
.RI "\fBversion_compare\fP ($version1, $version2, $operator=\fBnull\fP)"
.br
.ti -1c
.RI "\fBftok\fP ($pathname, $proj)"
.br
.ti -1c
.RI "\fBstr_rot13\fP ($str)"
.br
.ti -1c
.RI "\fBstream_get_filters\fP ()"
.br
.ti -1c
.RI "\fBstream_isatty\fP ($name)"
.br
.ti -1c
.RI "\fBstream_filter_register\fP ($filtername, $classname)"
.br
.ti -1c
.RI "\fBstream_bucket_make_writeable\fP ($brigade)"
.br
.ti -1c
.RI "\fBstream_bucket_prepend\fP ($brigade, $bucket)"
.br
.ti -1c
.RI "\fBstream_bucket_append\fP ($brigade, $bucket)"
.br
.ti -1c
.RI "\fBstream_bucket_new\fP ($stream, $buffer)"
.br
.ti -1c
.RI "\fBoutput_add_rewrite_var\fP ($name, $value)"
.br
.ti -1c
.RI "\fBoutput_reset_rewrite_vars\fP ()"
.br
.ti -1c
.RI "\fBsys_get_temp_dir\fP ()"
.br
.ti -1c
.RI "\fBrealpath_cache_get\fP ()"
.br
.ti -1c
.RI "\fBrealpath_cache_size\fP ()"
.br
.ti -1c
.RI "\fBget_mangled_object_vars\fP ($obj)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBARRAY_FILTER_USE_BOTH\fP 1"
.br
.ti -1c
.RI "const \fBARRAY_FILTER_USE_KEY\fP 2"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "array_change_key_case (array $input,  $case = \fC\fBnull\fP\fP)"
Changes all keys in an array \fBarray $input \fP The array to work on 
.PP
\fBParameters\fP
.RS 4
\fI$case\fP [optional] 
.RE
.PP
Either CASE_UPPER or CASE_LOWER (default) 
.PP
\fBReturns\fP
.RS 4
array an array with its keys lower or uppercased 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "array_chunk (array $input,  $size,  $preserve_keys = \fC\fBnull\fP\fP)"
Split an array into chunks \fBarray $input \fP The array to work on 
.PP
\fBParameters\fP
.RS 4
\fI$size\fP 
.RE
.PP
The size of each chunk 
.PP
\fBParameters\fP
.RS 4
\fI$preserve_keys\fP [optional] 
.RE
.PP
When set to true keys will be preserved\&. Default is false which will reindex the chunk numerically 
.PP
\fBReturns\fP
.RS 4
array a multidimensional numerically indexed array, starting with zero, with each dimension containing size elements\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "array_column (array $array,  $column,  $index_key = \fC\fBnull\fP\fP)"
(PHP 5 >=5\&.5\&.0)
.br
 Return the values from a single column in the input array \fBarray $array \fP\fBA\fP multi-dimensional array (record set) from which to pull a column of values\&.
.PP
\fBParameters\fP
.RS 4
\fI$column\fP 
.RE
.PP
The column of values to return\&. This value may be the integer key of the column you wish to retrieve, or it may be the string key name for an associative array\&. It may also be NULL to return complete arrays (useful together with index_key to reindex the array)\&.
.PP
\fBParameters\fP
.RS 4
\fI$index_key\fP [optional] 
.RE
.PP
The column to use as the index/keys for the returned array\&. This value may be the integer key of the column, or it may be the string key name\&.
.PP
\fBReturns\fP
.RS 4
array Returns an array of values representing a single column from the input array\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.5 
.RE
.PP

.SS "array_combine (array $keys, array $values)"
Creates an array by using one array for keys and another for its values \fBarray $keys \fP Array of keys to be used\&. Illegal values for key will be converted to string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$values\fP 
.RE
.PP
Array of values to be used 
.PP
\fBReturns\fP
.RS 4
array|false the combined array, false if the number of elements for each array isn't equal or if the arrays are empty\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.PP
\fBExamples\fP
.in +1c
\fB/usr/local/var/www/safaricom\-sdp\-sdk/vendor/roave/better\-reflection/src/Reflection/ReflectionClass\&.php\fP\&.
.SS "array_count_values (array $input)"
Counts all the values of an array \fBarray $input \fP The array of values to count 
.PP
\fBReturns\fP
.RS 4
array an associative array of values from input as keys and their count as value\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "array_diff (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP)"
Computes the difference of arrays \fBarray $array1 \fP The array to compare from 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
An array to compare against 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
array an array containing all the entries from array1 that are not present in any of the other arrays\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.1 
.PP
5\&.0 
.RE
.PP

.SS "array_diff_assoc (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP)"
Computes the difference of arrays with additional index check \fBarray $array1 \fP The array to compare from 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
An array to compare against 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
array an array containing all the values from array1 that are not present in any of the other arrays\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.3 
.PP
5\&.0 
.RE
.PP

.SS "array_diff_key (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP)"
Computes the difference of arrays using keys for comparison \fBarray $array1 \fP The array to compare from 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
An array to compare against 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
array an array containing all the entries from array1 whose keys are not present in any of the other arrays\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.1 
.RE
.PP

.SS "array_diff_uassoc (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP,  $key_compare_func)"
Computes the difference of arrays with additional index check which is performed by a user supplied callback function \fBarray $array1 \fP The array to compare from 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
An array to compare against 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.br
\fI$key_compare_func\fP 
.RE
.PP
callback function to use\&. The callback function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second\&. 
.PP
\fBReturns\fP
.RS 4
array an array containing all the entries from array1 that are not present in any of the other arrays\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "array_diff_ukey (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP,  $key_compare_func)"
Computes the difference of arrays using a callback function on the keys for comparison \fBarray $array1 \fP The array to compare from 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
An array to compare against 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.br
\fI$key_compare_func\fP 
.RE
.PP
callback function to use\&. The callback function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second\&. 
.PP
\fBReturns\fP
.RS 4
array an array containing all the entries from array1 that are not present in any of the other arrays\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.1 
.RE
.PP

.SS "array_filter (array $input,  $callback = \fC\fBnull\fP\fP,  $flag = \fC0\fP)"
Iterates over each value in the \fBarray\fP passing them to the \fBcallback\fP function\&. If the \fBcallback\fP function returns true, the current value from \fBarray\fP is returned into the result array\&. Array keys are preserved\&. \fBarray $input \fP The array to iterate over 
.PP
\fBParameters\fP
.RS 4
\fI$callback\fP [optional] 
.RE
.PP
The callback function to use 
.PP
If no callback is supplied, all entries of input equal to false (see converting to boolean) will be removed\&. 
.PP
\fBParameters\fP
.RS 4
\fI$flag\fP [optional] 
.RE
.PP
Flag determining what arguments are sent to \fIcallback\fP: 
.PP
.PD 0
.IP "\(bu" 2
\fBARRAY_FILTER_USE_KEY\fP - pass key as the only argument to \fIcallback\fP instead of the value  
.IP "\(bu" 2
\fBARRAY_FILTER_USE_BOTH\fP - pass both value and key as arguments to \fIcallback\fP instead of the value  
.PP
\fBReturns\fP
.RS 4
array the filtered array\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.PP
\fBExamples\fP
.in +1c
\fB/usr/local/var/www/safaricom\-sdp\-sdk/vendor/roave/better\-reflection/src/Reflection/ReflectionClass\&.php\fP\&.
.SS "array_flip (array $array)"
Exchanges all keys with their associated values in an array \fBarray $array \fP An array of key/value pairs to be flipped\&. 
.PP
\fBReturns\fP
.RS 4
array Returns the flipped array\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "array_intersect (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP)"
Computes the intersection of arrays \fBarray $array1 \fP The array with master values to check\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
An array to compare values against\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
array an array containing all of the values in array1 whose values exist in all of the parameters\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.1 
.PP
5\&.0 
.RE
.PP

.SS "array_intersect_assoc (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP)"
Computes the intersection of arrays with additional index check \fBarray $array1 \fP The array with master values to check\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
An array to compare values against\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
array an associative array containing all the values in array1 that are present in all of the arguments\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.3 
.PP
5\&.0 
.RE
.PP

.SS "array_intersect_key (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP)"
Computes the intersection of arrays using keys for comparison \fBarray $array1 \fP The array with master keys to check\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
An array to compare keys against\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
array an associative array containing all the entries of array1 which have keys that are present in all arguments\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.1 
.RE
.PP

.SS "array_intersect_uassoc (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP,  $key_compare_func)"
Computes the intersection of arrays with additional index check, compares indexes by a callback function \fBarray $array1 \fP Initial array for comparison of the arrays\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
First array to compare keys against\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.br
\fI$key_compare_func\fP 
.RE
.PP
User supplied callback function to do the comparison\&. 
.PP
\fBReturns\fP
.RS 4
array the values of array1 whose values exist in all of the arguments\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "array_intersect_ukey (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP,  $key_compare_func)"
Computes the intersection of arrays using a callback function on the keys for comparison \fBarray $array1 \fP Initial array for comparison of the arrays\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
First array to compare keys against\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.br
\fI$key_compare_func\fP 
.RE
.PP
User supplied callback function to do the comparison\&. 
.PP
\fBReturns\fP
.RS 4
array the values of array1 whose keys exist in all the arguments\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.1 
.RE
.PP

.SS "array_key_exists ( $key, array $search)"
Checks if the given key or index exists in the array \fBmixed $key \fP Value to check\&. 
.PP
\fBParameters\fP
.RS 4
\fI$search\fP 
.RE
.PP
An array with keys to check\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.7 
.PP
5\&.0 
.RE
.PP

.PP
\fBExamples\fP
.in +1c
\fB/usr/local/var/www/safaricom\-sdp\-sdk/vendor/roave/better\-reflection/src/Reflection/ReflectionClass\&.php\fP\&.
.SS "array_key_first (array $array)"
Gets the first key of an array
.PP
Get the first key of the given array without affecting the internal array pointer\&.
.PP
\fBarray $array An array  string|int|null Returns the first key of array if the array is not empty; NULL otherwise\&.  7\&.3 \fP
.SS "array_key_last (array $array)"
Gets the last key of an array
.PP
Get the last key of the given array without affecting the internal array pointer\&.
.PP
\fBarray $array An array  string|int|null Returns the last key of array if the array is not empty; NULL otherwise\&.  7\&.3 \fP
.SS "array_keys (array $input,  $search_value = \fC\fBnull\fP\fP,  $strict = \fC\fBnull\fP\fP)"
Return all the keys of an array \fBarray $input \fP An array containing keys to return\&. 
.PP
\fBParameters\fP
.RS 4
\fI$search_value\fP [optional] 
.RE
.PP
If specified, then only keys containing these values are returned\&. 
.PP
\fBParameters\fP
.RS 4
\fI$strict\fP [optional] 
.RE
.PP
Determines if strict comparison (===) should be used during the search\&. 
.PP
\fBReturns\fP
.RS 4
array an array of all the keys in input\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "array_map ( $callback, array $arr1, array $_ = \fC\fBnull\fP\fP)"
Applies the callback to the elements of the given arrays \fBcallback $callback \fP Callback function to run for each element in each array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$arr1\fP 
.RE
.PP
An array to run through the callback function\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
array an array containing all the elements of arr1 after applying the callback function to each one\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.PP
\fBExamples\fP
.in +1c
\fB/usr/local/var/www/safaricom\-sdp\-sdk/vendor/roave/better\-reflection/src/Reflection/ReflectionClass\&.php\fP\&.
.SS "array_merge_recursive (array $_ = \fC\fBnull\fP\fP)"
Merge two or more arrays recursively \fBarray $_ [optional] Variable list of arrays to recursively merge\&.  array An array of values resulted from merging the arguments together\&.  4\&.0\&.1  5\&.0 \fP
.SS "array_pad (array $input,  $pad_size,  $pad_value)"
Pad array to the specified length with a value \fBarray $input \fP Initial array of values to pad\&. 
.PP
\fBParameters\fP
.RS 4
\fI$pad_size\fP 
.RE
.PP
New size of the array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$pad_value\fP 
.RE
.PP
Value to pad if input is less than pad_size\&. 
.PP
\fBReturns\fP
.RS 4
array a copy of the input padded to size specified by pad_size with value pad_value\&. If pad_size is positive then the array is padded on the right, if it's negative then on the left\&. If the absolute value of pad_size is less than or equal to the length of the input then no padding takes place\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "array_product (array $array)"
Calculate the product of values in an array \fBarray $array \fP The array\&. 
.PP
\fBReturns\fP
.RS 4
int|float the product as an integer or float\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.1 
.RE
.PP

.SS "array_rand (array $input,  $num_req = \fC\fBnull\fP\fP)"
Pick one or more random entries out of an array \fBarray $input \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$num_req\fP [optional] 
.RE
.PP
Specifies how many entries you want to pick\&. 
.PP
\fBReturns\fP
.RS 4
mixed If you are picking only one entry, array_rand returns the key for a random entry\&. Otherwise, it returns an array of keys for the random entries\&. This is done so that you can pick random keys as well as values out of the array\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "array_reduce (array $input,  $function,  $initial = \fC\fBnull\fP\fP)"
Iteratively reduce the array to a single value using a callback function \fBarray $input \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$function\fP 
.RE
.PP
The callback function\&. 
.PP
\fBParameters\fP
.RS 4
\fI$initial\fP [optional] 
.RE
.PP
If the optional initial is available, it will be used at the beginning of the process, or as a final result in case the array is empty\&. 
.PP
\fBReturns\fP
.RS 4
mixed the resulting value\&. 
.RE
.PP
.PP
If the array is empty and initial is not passed, array_reduce returns null\&. 
.PP
\fBSince\fP
.RS 4
4\&.0\&.5 
.PP
5\&.0 
.RE
.PP

.SS "array_replace (array $array, array $array1, array $array2 = \fC\fBnull\fP\fP, array $_ = \fC\fBnull\fP\fP)"
\fBarray_replace()\fP replaces the values of the first array with the same values from all the following arrays\&. If a key from the first array exists in the second array, its value will be replaced by the value from the second array\&. If the key exists in the second array, and not the first, it will be created in the first array\&. If a key only exists in the first array, it will be left as is\&. If several arrays are passed for replacement, they will be processed in order, the later arrays overwriting the previous values\&. \fBarray_replace()\fP is not recursive : it will replace values in the first array by whatever type is in the second array\&. \fBarray $array \fP The array in which elements are replaced\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array1\fP 
.RE
.PP
The array from which elements will be extracted\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP [optional] 
.br
\fI$_\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
array or null if an error occurs\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.3 
.RE
.PP

.SS "array_replace_recursive (array $array, array $array1, array $array2 = \fC\fBnull\fP\fP, array $_ = \fC\fBnull\fP\fP)"
Replaces elements from passed arrays into the first array recursively \fBarray $array \fP The array in which elements are replaced\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array1\fP 
.RE
.PP
The array from which elements will be extracted\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP [optional] 
.br
\fI$_\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
array an array, or  if an error occurs\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.3 
.RE
.PP

.SS "array_reverse (array $array,  $preserve_keys = \fC\fBnull\fP\fP)"
Return an array with elements in reverse order \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$preserve_keys\fP [optional] 
.RE
.PP
If set to true keys are preserved\&. 
.PP
\fBReturns\fP
.RS 4
array the reversed array\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.PP
\fBExamples\fP
.in +1c
\fB/usr/local/var/www/safaricom\-sdp\-sdk/vendor/roave/better\-reflection/src/Reflection/ReflectionClass\&.php\fP\&.
.SS "array_sum (array $array)"
Calculate the sum of values in an array \fBarray $array \fP The input array\&. 
.PP
\fBReturns\fP
.RS 4
int|float the sum of values as an integer or float\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "array_udiff (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP,  $data_compare_func)"
Computes the difference of arrays by using a callback function for data comparison \fBarray $array1 \fP The first array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
The second array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.br
\fI$data_compare_func\fP 
.RE
.PP
The callback comparison function\&. 
.PP
The user supplied callback function is used for comparison\&. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second\&. 
.PP
\fBReturns\fP
.RS 4
array an array containing all the values of array1 that are not present in any of the other arguments\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "array_udiff_assoc (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP,  $data_compare_func)"
Computes the difference of arrays with additional index check, compares data by a callback function \fBarray $array1 \fP The first array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
The second array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.br
\fI$data_compare_func\fP 
.RE
.PP
The callback comparison function\&. 
.PP
The user supplied callback function is used for comparison\&. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second\&. 
.PP
\fBReturns\fP
.RS 4
array array_udiff_assoc returns an array containing all the values from array1 that are not present in any of the other arguments\&. Note that the keys are used in the comparison unlike array_diff and array_udiff\&. The comparison of arrays' data is performed by using an user-supplied callback\&. In this aspect the behaviour is opposite to the behaviour of array_diff_assoc which uses internal function for comparison\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "array_udiff_uassoc (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP,  $data_compare_func,  $key_compare_func)"
Computes the difference of arrays with additional index check, compares data and indexes by a callback function \fBarray $array1 \fP The first array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
The second array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.br
\fI$data_compare_func\fP 
.RE
.PP
The callback comparison function\&. 
.PP
The user supplied callback function is used for comparison\&. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second\&. 
.PP
The comparison of arrays' data is performed by using an user-supplied callback : data_compare_func\&. In this aspect the behaviour is opposite to the behaviour of array_diff_assoc which uses internal function for comparison\&. 
.PP
\fBParameters\fP
.RS 4
\fI$key_compare_func\fP 
.RE
.PP
The comparison of keys (indices) is done also by the callback function key_compare_func\&. This behaviour is unlike what array_udiff_assoc does, since the latter compares the indices by using an internal function\&. 
.PP
\fBReturns\fP
.RS 4
array an array containing all the values from array1 that are not present in any of the other arguments\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "array_uintersect (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP,  $data_compare_func)"
Computes the intersection of arrays, compares data by a callback function \fBarray $array1 \fP The first array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
The second array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.br
\fI$data_compare_func\fP 
.RE
.PP
The callback comparison function\&. 
.PP
The user supplied callback function is used for comparison\&. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second\&. 
.PP
\fBReturns\fP
.RS 4
array an array containing all the values of array1 that are present in all the arguments\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "array_uintersect_assoc (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP,  $data_compare_func)"
Computes the intersection of arrays with additional index check, compares data by a callback function \fBarray $array1 \fP The first array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
The second array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.br
\fI$data_compare_func\fP 
.RE
.PP
For comparison is used the user supplied callback function\&. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second\&. 
.PP
\fBReturns\fP
.RS 4
array an array containing all the values of array1 that are present in all the arguments\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "array_uintersect_uassoc (array $array1, array $array2, array $_ = \fC\fBnull\fP\fP,  $data_compare_func,  $key_compare_func)"
Computes the intersection of arrays with additional index check, compares data and indexes by a callback functions \fBarray $array1 \fP The first array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP 
.RE
.PP
The second array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.br
\fI$data_compare_func\fP 
.RE
.PP
For comparison is used the user supplied callback function\&. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second\&. 
.PP
\fBParameters\fP
.RS 4
\fI$key_compare_func\fP 
.RE
.PP
Key comparison callback function\&. 
.PP
\fBReturns\fP
.RS 4
array an array containing all the values of array1 that are present in all the arguments\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "array_unique (array $array,  $sort_flags = \fC\fBSORT_STRING\fP\fP)"
Removes duplicate values from an array \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$sort_flags\fP [optional] 
.RE
.PP
The optional second parameter sort_flags may be used to modify the sorting behavior using these values: 
.PP
Sorting type flags: 
.PP
.PD 0
.IP "\(bu" 2
\fBSORT_REGULAR\fP - compare items normally (don't change types)  
.IP "\(bu" 2
\fBSORT_NUMERIC\fP - compare items numerically  
.IP "\(bu" 2
\fBSORT_STRING\fP - compare items as strings  
.IP "\(bu" 2
\fBSORT_LOCALE_STRING\fP - compare items as strings, based on the current locale  
.PP
\fBReturns\fP
.RS 4
array the filtered array\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.1 
.PP
5\&.0 
.RE
.PP

.SS "array_values (array $input)"
Return all the values of an array \fBarray $input \fP The array\&. 
.PP
\fBReturns\fP
.RS 4
array an indexed array of values\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.PP
\fBExamples\fP
.in +1c
\fB/usr/local/var/www/safaricom\-sdp\-sdk/vendor/roave/better\-reflection/src/Reflection/ReflectionClass\&.php\fP\&.
.SS "assert ( $assertion,  $description = \fC''\fP)"
Checks if assertion is  \fBmixed $assertion \fP The assertion\&. In PHP 5, this must be either a string to be evaluated or a boolean to be tested\&. In PHP 7, this may also be any expression that returns a value, which will be executed and the result used to indicate whether the assertion succeeded or failed\&.
.br
 Since 7\&.2\&.0 using string is deprecated\&. 
.PP
\fBParameters\fP
.RS 4
\fI$description\fP [optional] 
.RE
.PP
An optional description that will be included in the failure message if the assertion fails\&.
.PP
\fBReturns\fP
.RS 4
bool false if the assertion is false, true otherwise\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.PP
\fBExamples\fP
.in +1c
\fB/usr/local/var/www/safaricom\-sdp\-sdk/vendor/roave/better\-reflection/src/Reflection/ReflectionClass\&.php\fP\&.
.SS "assert_options ( $what,  $value = \fC\fBnull\fP\fP)"
Set/get the various assert flags \fBint $what \fP Options 
.PP
Option 
.PP
INI Setting 
.PP
Default value 
.PP
Description  
.PP
ASSERT_ACTIVE 
.PP
assert\&.active 
.PP
1 
.PP
enable assert evaluation  
.PP
ASSERT_WARNING 
.PP
assert\&.warning 
.PP
1 
.PP
issue a PHP warning for each failed assertion  
.PP
ASSERT_BAIL 
.PP
assert\&.bail 
.PP
0 
.PP
terminate execution on failed assertions  
.PP
ASSERT_QUIET_EVAL 
.PP
assert\&.quiet_eval 
.PP
0 
.PP
disable error_reporting during assertion expression evaluation   
.PP
ASSERT_CALLBACK 
.PP
assert\&.callback 
.PP
null 
.PP
Callback to call on failed assertions  
.PP
\fBParameters\fP
.RS 4
\fI$value\fP [optional] 
.RE
.PP
An optional new value for the option\&. 
.PP
\fBReturns\fP
.RS 4
mixed the original setting of any option or false on errors\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "ftok ( $pathname,  $proj)"
Convert a pathname and a project identifier to a System V IPC key \fBstring $pathname \fP Path to an accessible file\&. 
.PP
\fBParameters\fP
.RS 4
\fI$proj\fP 
.RE
.PP
Project identifier\&. This must be a one character string\&. 
.PP
\fBReturns\fP
.RS 4
int On success the return value will be the created key value, otherwise -1 is returned\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "get_mangled_object_vars ( $obj)"
It returns the same result as (array) $object, with the exception that it ignores overloaded array casts, such as used by \fBArrayObject\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fI$obj\fP 
.RE
.PP
\fBReturns\fP
.RS 4
array returns the mangled object properties 
.RE
.PP
\fBSince\fP
.RS 4
7\&.4 
.RE
.PP

.SS "key_exists ( $key,  $search)"
Checks if the given key or index exists in the array\&. The name of this function is \fBarray_key_exists()\fP in PHP > 4\&.0\&.6\&. \fBmixed $key \fP Value to check\&. 
.PP
\fBParameters\fP
.RS 4
\fI$search\fP 
.RE
.PP
An array with keys to check\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.7 
.PP
5\&.0 
.RE
.PP

.SS "output_add_rewrite_var ( $name,  $value)"
Add URL rewriter values \fBstring $name \fP The variable name\&. 
.PP
\fBParameters\fP
.RS 4
\fI$value\fP 
.RE
.PP
The variable value\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.3 
.PP
5\&.0 
.RE
.PP

.SS "output_reset_rewrite_vars ()"
Reset URL rewriter values 
.PP
Version 
.PP
Description 
.PP
</thead>
.PP
<tbody> 
.PP
7\&.1\&.0 
.PP
Before PHP 7\&.1\&.0, rewrite vars set by \fCoutput_add_rewrite_var()\fP use the same Session module trans sid output buffer\&. Since PHP 7\&.1\&.0, dedicated output buffer is used and {
.PP
\fBSee also\fP
.RS 4
\fBoutput_reset_rewrite_vars()\fP} only removes rewrite vars \fBdefined\fP by {
.PP
\fBoutput_add_rewrite_var()\fP}\&.  
.RE
.PP
</tbody>
.PP
\fBbool true on success or false on failure\&.  4\&.3  5\&.0 \fP
.SS "pos (& $arg)"
<function>current</function> \fB$arg  4\&.0  5\&.0 \fP
.SS "realpath_cache_get ()"
Get the contents of the realpath cache\&. \fBarray Returns an array of realpath cache entries\&. The keys are original path entries, and the values are arrays of data items, containing the resolved path, expiration date, and other options kept in the cache\&.  5\&.3\&.2 \fP
.SS "realpath_cache_size ()"
Get the amount of memory used by the realpath cache\&. \fBint Returns how much memory realpath cache is using\&.  5\&.3\&.2 \fP
.SS "sizeof ( $var,  $mode = \fC\fBCOUNT_NORMAL\fP\fP)"
<function>count</function> \fBarray|Countable $var  int $mode [optional]  int  4\&.0  5\&.0 \fP
.SS "str_rot13 ( $str)"
Perform the rot13 transform on a string \fBstring $str \fP The input string\&. 
.PP
\fBReturns\fP
.RS 4
string the ROT13 version of the given string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "stream_bucket_append ( $brigade,  $bucket)"
Append bucket to brigade \fBresource $brigade  object $bucket  void  5\&.0 \fP
.SS "stream_bucket_make_writeable ( $brigade)"
Return a bucket object from the brigade for operating on \fBresource $brigade  object  5\&.0 \fP
.SS "stream_bucket_new ( $stream,  $buffer)"
Create a new bucket for use on the current stream \fBresource $stream  string $buffer  object  5\&.0 \fP
.SS "stream_bucket_prepend ( $brigade,  $bucket)"
Prepend bucket to brigade \fBresource $brigade  resource $bucket  void  5\&.0 \fP
.SS "stream_filter_register ( $filtername,  $classname)"
Register a user defined stream filter \fBstring $filtername \fP The filter name to be registered\&. 
.PP
\fBParameters\fP
.RS 4
\fI$classname\fP 
.RE
.PP
To implement a filter, you need to define a class as an extension of \fBphp_user_filter\fP with a number of member functions as defined below\&. When performing read/write operations on the stream to which your filter is attached, PHP will pass the data through your filter (and any other filters attached to that stream) so that the data may be modified as desired\&. You must implement the methods exactly as described below - doing otherwise will lead to undefined behaviour\&. 
.PP
intfilter resourcein resourceout intconsumed boolclosing 
.PP
This method is called whenever data is read from or written to the attached stream (such as with fread or fwrite)\&. in is a resource pointing to a bucket brigade which contains one or more bucket objects containing data to be filtered\&. out is a resource pointing to a second bucket brigade into which your modified buckets should be placed\&. consumed, which must always be declared by reference, should be incremented by the length of the data which your filter reads in and alters\&. In most cases this means you will increment consumed by $bucket->datalen for each $bucket\&. If the stream is in the process of closing (and therefore this is the last pass through the filterchain), the closing parameter will be set to true\&. The filter method must return one of three values upon completion\&. 
.PP
Return Value 
.PP
Meaning  
.PP
PSFS_PASS_ON 
.PP
Filter processed successfully with data available in the out bucket brigade\&.   
.PP
PSFS_FEED_ME 
.PP
Filter processed successfully, however no data was available to return\&. More data is required from the stream or prior filter\&.   
.PP
PSFS_ERR_FATAL (default) 
.PP
The filter experienced an unrecoverable error and cannot continue\&.   
.PP
boolonCreate This method is called during instantiation of the filter class object\&. If your filter allocates or initializes any other resources (such as a buffer), this is the place to do it\&. Your implementation of this method should return false on failure, or true on success\&. When your filter is first instantiated, and yourfilter->onCreate() is called, a number of properties will be available as shown in the table below\&. 
.PP
Property 
.PP
Contents  
.PP
FilterClass->filtername 
.PP
\fBA\fP string containing the name the filter was instantiated with\&. Filters may be registered under multiple names or under wildcards\&. Use this property to determine which name was used\&.   
.PP
FilterClass->params 
.PP
The contents of the params parameter passed to stream_filter_append or stream_filter_prepend\&.   
.PP
FilterClass->stream 
.PP
The stream resource being filtered\&. Maybe available only during filter calls when the closing parameter is set to false\&.   
.PP
voidonClose 
.PP
This method is called upon filter shutdown (typically, this is also during stream shutdown), and is executed after the flush method is called\&. If any resources were allocated or initialzed during onCreate() this would be the time to destroy or dispose of them\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
.PP
stream_filter_register will return false if the filtername is already defined\&. 
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "stream_get_filters ()"
Retrieve list of registered filters \fBarray an indexed array containing the name of all stream filters available\&.  5\&.0 \fP
.SS "stream_isatty ( $name)"
Check if a stream is a TTY \fBresource $name  bool  7\&.2 \fP
.SS "sys_get_temp_dir ()"
Returns directory path used for temporary files \fBstring the path of the temporary directory\&.  5\&.2\&.1 \fP
.SS "version_compare ( $version1,  $version2,  $operator = \fC\fBnull\fP\fP)"
Compares two 'PHP-standardized' version number strings \fBstring $version1 \fP First version number\&. 
.PP
\fBParameters\fP
.RS 4
\fI$version2\fP 
.RE
.PP
Second version number\&. 
.PP
\fBParameters\fP
.RS 4
\fI$operator\fP [optional] 
.RE
.PP
If you specify the third optional operator argument, you can test for a particular relationship\&. The possible operators are: <, lt, <=, le, >, gt, >=, ge, ==, =, eq, !=, <>, ne respectively\&. 
.PP
This parameter is case-sensitive, so values should be lowercase\&. 
.PP
\fBReturns\fP
.RS 4
int|bool By default, version_compare returns -1 if the first version is lower than the second, 0 if they are equal, and 1 if the second is lower\&. 
.RE
.PP
.PP
When using the optional operator argument, the function will return true if the relationship is the one specified by the operator, false otherwise\&. 
.PP
\fBSince\fP
.RS 4
4\&.1 
.PP
5\&.0 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "const ARRAY_FILTER_USE_BOTH 1"

.SS "const ARRAY_FILTER_USE_KEY 2"

.SH "Author"
.PP 
Generated automatically by Doxygen for Safaricom SDP from the source code\&.
