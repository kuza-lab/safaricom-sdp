.TH "vendor/jetbrains/phpstorm-stubs/standard/standard_3.php" 3 "Sat Sep 26 2020" "Safaricom SDP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
vendor/jetbrains/phpstorm-stubs/standard/standard_3.php
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBgetlastmod\fP ()"
.br
.ti -1c
.RI "\fBbase64_decode\fP ($data, $strict=\fBnull\fP)"
.br
.ti -1c
.RI "\fBbase64_encode\fP ($data)"
.br
.ti -1c
.RI "\fBconvert_uuencode\fP ($data)"
.br
.ti -1c
.RI "\fBconvert_uudecode\fP ($data)"
.br
.ti -1c
.RI "\fBabs\fP ($number)"
.br
.ti -1c
.RI "\fBceil\fP ($value)"
.br
.ti -1c
.RI "\fBfloor\fP ($value)"
.br
.ti -1c
.RI "\fBround\fP ($val, $precision=0, $mode=\fBPHP_ROUND_HALF_UP\fP)"
.br
.ti -1c
.RI "\fBsin\fP ($arg)"
.br
.ti -1c
.RI "\fBcos\fP ($arg)"
.br
.ti -1c
.RI "\fBtan\fP ($arg)"
.br
.ti -1c
.RI "\fBasin\fP ($arg)"
.br
.ti -1c
.RI "\fBacos\fP ($arg)"
.br
.ti -1c
.RI "\fBatan\fP ($arg)"
.br
.ti -1c
.RI "\fBatanh\fP ($arg)"
.br
.ti -1c
.RI "\fBatan2\fP ($y, $x)"
.br
.ti -1c
.RI "\fBsinh\fP ($arg)"
.br
.ti -1c
.RI "\fBcosh\fP ($arg)"
.br
.ti -1c
.RI "\fBtanh\fP ($arg)"
.br
.ti -1c
.RI "\fBasinh\fP ($arg)"
.br
.ti -1c
.RI "\fBacosh\fP ($arg)"
.br
.ti -1c
.RI "\fBexpm1\fP ($arg)"
.br
.ti -1c
.RI "\fBlog1p\fP ($number)"
.br
.ti -1c
.RI "\fBpi\fP ()"
.br
.ti -1c
.RI "\fBis_finite\fP ($val)"
.br
.ti -1c
.RI "\fBis_nan\fP ($val)"
.br
.ti -1c
.RI "\fBintdiv\fP ($dividend, $divisor)"
.br
.ti -1c
.RI "\fBis_infinite\fP ($val)"
.br
.ti -1c
.RI "\fBpow\fP ($base, $\fBexp\fP)"
.br
.ti -1c
.RI "\fBexp\fP ($arg)"
.br
.ti -1c
.RI "\fBlog\fP ($arg, $base=\fBnull\fP)"
.br
.ti -1c
.RI "\fBlog10\fP ($arg)"
.br
.ti -1c
.RI "\fBsqrt\fP ($arg)"
.br
.ti -1c
.RI "\fBhypot\fP ($x, $y)"
.br
.ti -1c
.RI "\fBdeg2rad\fP ($number)"
.br
.ti -1c
.RI "\fBrad2deg\fP ($number)"
.br
.ti -1c
.RI "\fBbindec\fP ($binary_string)"
.br
.ti -1c
.RI "\fBhexdec\fP ($hex_string)"
.br
.ti -1c
.RI "\fBoctdec\fP ($octal_string)"
.br
.ti -1c
.RI "\fBdecbin\fP ($number)"
.br
.ti -1c
.RI "\fBdecoct\fP ($number)"
.br
.ti -1c
.RI "\fBdechex\fP ($number)"
.br
.ti -1c
.RI "\fBbase_convert\fP ($number, $frombase, $tobase)"
.br
.ti -1c
.RI "\fBnumber_format\fP ($number, $decimals=0, $dec_point='\&.', $thousands_sep=',')"
.br
.ti -1c
.RI "\fBfmod\fP ($x, $y)"
.br
.ti -1c
.RI "\fBinet_ntop\fP ($in_addr)"
.br
.ti -1c
.RI "\fBinet_pton\fP ($address)"
.br
.ti -1c
.RI "\fBip2long\fP ($ip_address)"
.br
.ti -1c
.RI "\fBlong2ip\fP ($proper_address)"
.br
.ti -1c
.RI "\fBgetenv\fP ($varname=\fBnull\fP, $local_only=\fBfalse\fP)"
.br
.ti -1c
.RI "\fBputenv\fP ($setting)"
.br
.ti -1c
.RI "\fBgetopt\fP ($options, array $longopts=\fBnull\fP, &$optind=\fBnull\fP)"
.br
.ti -1c
.RI "\fBsys_getloadavg\fP ()"
.br
.ti -1c
.RI "\fBmicrotime\fP ($get_as_float=\fBnull\fP)"
.br
.ti -1c
.RI "\fBgettimeofday\fP ($return_float=\fBnull\fP)"
.br
.ti -1c
.RI "\fBgetrusage\fP ($who=\fBnull\fP)"
.br
.ti -1c
.RI "\fBuniqid\fP ($prefix='', $more_entropy=\fBfalse\fP)"
.br
.ti -1c
.RI "\fBquoted_printable_decode\fP ($str)"
.br
.ti -1c
.RI "\fBquoted_printable_encode\fP ($str)"
.br
.ti -1c
.RI "\fBconvert_cyr_string\fP ($str, $from, $to)"
.br
.ti -1c
.RI "\fBget_current_user\fP ()"
.br
.ti -1c
.RI "\fBset_time_limit\fP ($seconds)"
.br
.ti -1c
.RI "\fBget_cfg_var\fP ($option)"
.br
.ti -1c
.RI "\fBmagic_quotes_runtime\fP ($new_setting)"
.br
.ti -1c
.RI "\fBset_magic_quotes_runtime\fP ($new_setting)"
.br
.ti -1c
.RI "\fBget_magic_quotes_gpc\fP ()"
.br
.ti -1c
.RI "\fBget_magic_quotes_runtime\fP ()"
.br
.ti -1c
.RI "\fBimport_request_variables\fP ($types, $prefix=\fBnull\fP)"
.br
.ti -1c
.RI "\fBerror_log\fP ($message, $message_type=\fBnull\fP, $destination=\fBnull\fP, $extra_headers=\fBnull\fP)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "abs ( $number)"
Absolute value \fBmixed $number \fP The numeric value to process 
.PP
\fBReturns\fP
.RS 4
float|int The absolute value of number\&. If the argument number is of type float, the return type is also float, otherwise it is integer (as float usually has a bigger value range than integer)\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "acos ( $arg)"
Arc cosine \fBfloat $arg \fP The argument to process 
.PP
\fBReturns\fP
.RS 4
float The arc cosine of arg in radians\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "acosh ( $arg)"
Inverse hyperbolic cosine \fBfloat $arg \fP The value to process 
.PP
\fBReturns\fP
.RS 4
float The inverse hyperbolic cosine of arg 
.RE
.PP
\fBSince\fP
.RS 4
4\&.1 
.PP
5\&.0 
.RE
.PP

.SS "asin ( $arg)"
Arc sine \fBfloat $arg \fP The argument to process 
.PP
\fBReturns\fP
.RS 4
float The arc sine of arg in radians 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "asinh ( $arg)"
Inverse hyperbolic sine \fBfloat $arg \fP The argument to process 
.PP
\fBReturns\fP
.RS 4
float The inverse hyperbolic sine of arg 
.RE
.PP
\fBSince\fP
.RS 4
4\&.1 
.PP
5\&.0 
.RE
.PP

.SS "atan ( $arg)"
Arc tangent \fBfloat $arg \fP The argument to process 
.PP
\fBReturns\fP
.RS 4
float The arc tangent of arg in radians\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "atan2 ( $y,  $x)"
Arc tangent of two variables \fBfloat $y \fP Dividend parameter 
.PP
\fBParameters\fP
.RS 4
\fI$x\fP 
.RE
.PP
Divisor parameter 
.PP
\fBReturns\fP
.RS 4
float The arc tangent of y/x in radians\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "atanh ( $arg)"
Inverse hyperbolic tangent \fBfloat $arg \fP The argument to process 
.PP
\fBReturns\fP
.RS 4
float Inverse hyperbolic tangent of arg 
.RE
.PP
\fBSince\fP
.RS 4
4\&.1 
.PP
5\&.0 
.RE
.PP

.SS "base64_decode ( $data,  $strict = \fC\fBnull\fP\fP)"
Decodes data encoded with MIME base64 \fBstring $data \fP The encoded data\&. 
.PP
\fBParameters\fP
.RS 4
\fI$strict\fP [optional] 
.RE
.PP
Returns false if input contains character from outside the base64 alphabet\&. 
.PP
\fBReturns\fP
.RS 4
string|false the original data or false on failure\&. The returned data may be binary\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "base64_encode ( $data)"
Encodes data with MIME base64 \fBstring $data \fP The data to encode\&. 
.PP
\fBReturns\fP
.RS 4
string The encoded data, as a string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "base_convert ( $number,  $frombase,  $tobase)"
Convert a number between arbitrary bases \fBstring $number \fP The number to convert 
.PP
\fBParameters\fP
.RS 4
\fI$frombase\fP 
.RE
.PP
The base number is in 
.PP
\fBParameters\fP
.RS 4
\fI$tobase\fP 
.RE
.PP
The base to convert number to 
.PP
\fBReturns\fP
.RS 4
string number converted to base tobase 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "bindec ( $binary_string)"
Binary to decimal \fBstring $binary_string \fP The binary string to convert 
.PP
\fBReturns\fP
.RS 4
int|float The decimal value of binary_string 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "ceil ( $value)"
Round fractions up \fBfloat $value \fP The value to round 
.PP
\fBReturns\fP
.RS 4
float|false value rounded up to the next highest integer\&. The return value of ceil is still of type float as the value range of float is usually bigger than that of integer\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "convert_cyr_string ( $str,  $from,  $to)"
Convert from one Cyrillic character set to another \fBstring $str \fP The string to be converted\&. 
.PP
\fBParameters\fP
.RS 4
\fI$from\fP 
.RE
.PP
The source Cyrillic character set, as a single character\&. 
.PP
\fBParameters\fP
.RS 4
\fI$to\fP 
.RE
.PP
The target Cyrillic character set, as a single character\&. 
.PP
\fBReturns\fP
.RS 4
string the converted string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.4 
.RE
.PP

.SS "convert_uudecode ( $data)"
Decode a uuencoded string \fBstring $data \fP The uuencoded data\&. 
.PP
\fBReturns\fP
.RS 4
string the decoded data as a string\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "convert_uuencode ( $data)"
Uuencode a string \fBstring $data \fP The data to be encoded\&. 
.PP
\fBReturns\fP
.RS 4
string the uuencoded data\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "cos ( $arg)"
Cosine \fBfloat $arg \fP An angle in radians 
.PP
\fBReturns\fP
.RS 4
float The cosine of arg 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "cosh ( $arg)"
Hyperbolic cosine \fBfloat $arg \fP The argument to process 
.PP
\fBReturns\fP
.RS 4
float The hyperbolic cosine of arg 
.RE
.PP
\fBSince\fP
.RS 4
4\&.1 
.PP
5\&.0 
.RE
.PP

.SS "decbin ( $number)"
Decimal to binary \fBint $number \fP Decimal value to convert 
.PP
of inputs on 32-bit machines 
.PP
positive number 
.PP
negative number 
.PP
return value  
.PP
0 
.PP
0  
.PP
1 
.PP
1  
.PP
2 
.PP
10  
.PP
\&.\&.\&. normal progression \&.\&.\&.  
.PP
2147483646 
.PP
1111111111111111111111111111110  
.PP
2147483647 (largest signed integer) 
.PP
1111111111111111111111111111111 (31 1's)  
.PP
2147483648 
.PP
-2147483648 
.PP
10000000000000000000000000000000  
.PP
\&.\&.\&. normal progression \&.\&.\&.  
.PP
4294967294 
.PP
-2 
.PP
11111111111111111111111111111110  
.PP
4294967295 (largest unsigned integer) 
.PP
-1 
.PP
11111111111111111111111111111111 (32 1's)  
.PP
of inputs on 64-bit machines 
.PP
positive number 
.PP
negative number 
.PP
return value  
.PP
0 
.PP
0  
.PP
1 
.PP
1  
.PP
2 
.PP
10  
.PP
\&.\&.\&. normal progression \&.\&.\&.  
.PP
9223372036854775806 
.PP
111111111111111111111111111111111111111111111111111111111111110  
.PP
9223372036854775807 (largest signed integer) 
.PP
111111111111111111111111111111111111111111111111111111111111111 (31 1's)  
.PP
-9223372036854775808 
.PP
1000000000000000000000000000000000000000000000000000000000000000  
.PP
\&.\&.\&. normal progression \&.\&.\&.  
.PP
-2 
.PP
1111111111111111111111111111111111111111111111111111111111111110  
.PP
-1 
.PP
1111111111111111111111111111111111111111111111111111111111111111 (64 1's)  
.PP
\fBReturns\fP
.RS 4
string Binary string representation of number 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "dechex ( $number)"
Decimal to hexadecimal \fBint $number \fP Decimal value to convert 
.PP
\fBReturns\fP
.RS 4
string Hexadecimal string representation of number 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "decoct ( $number)"
Decimal to octal \fBint $number \fP Decimal value to convert 
.PP
\fBReturns\fP
.RS 4
string Octal string representation of number 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "deg2rad ( $number)"
Converts the number in degrees to the radian equivalent \fBfloat $number \fP Angular value in degrees 
.PP
\fBReturns\fP
.RS 4
float The radian equivalent of number 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "error_log ( $message,  $message_type = \fC\fBnull\fP\fP,  $destination = \fC\fBnull\fP\fP,  $extra_headers = \fC\fBnull\fP\fP)"
Send an error message somewhere \fBstring $message \fP The error message that should be logged\&. 
.PP
\fBParameters\fP
.RS 4
\fI$message_type\fP [optional] 
.RE
.PP
Says where the error should go\&. The possible message types are as follows: 
.PP
log types 
.PP
0 
.PP
message is sent to PHP's system logger, using the Operating System's system logging mechanism or a file, depending on what the error_log configuration directive is set to\&. This is the default option\&.   
.PP
1 
.PP
message is sent by email to the address in the destination parameter\&. This is the only message type where the fourth parameter, extra_headers is used\&.   
.PP
2 
.PP
No longer an option\&.   
.PP
3 
.PP
message is appended to the file destination\&. \fBA\fP newline is not automatically added to the end of the message string\&.   
.PP
4 
.PP
message is sent directly to the SAPI logging handler\&.   
.PP
\fBParameters\fP
.RS 4
\fI$destination\fP [optional] 
.RE
.PP
The destination\&. Its meaning depends on the message_type parameter as described above\&. 
.PP
\fBParameters\fP
.RS 4
\fI$extra_headers\fP [optional] 
.RE
.PP
The extra headers\&. It's used when the message_type parameter is set to 1\&. This message type uses the same internal function as mail does\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "exp ( $arg)"
Calculates the exponent of <constant>e</constant> \fBfloat $arg \fP The argument to process 
.PP
\fBReturns\fP
.RS 4
float 'e' raised to the power of arg 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "expm1 ( $arg)"
Returns exp(number) - 1, computed in a way that is accurate even 
.PP
\fBSince\fP
.RS 4
4\&.1 
.PP
5\&.0 when the value of number is close to zero \fBfloat $arg \fP The argument to process 
.RE
.PP
\fBReturns\fP
.RS 4
float 'e' to the power of arg minus one 
.RE
.PP

.SS "floor ( $value)"
Round fractions down \fBfloat $value \fP The numeric value to round 
.PP
\fBReturns\fP
.RS 4
float|false value rounded to the next lowest integer\&. The return value of floor is still of type float because the value range of float is usually bigger than that of integer\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "fmod ( $x,  $y)"
Returns the floating point remainder (modulo) of the division 
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 of the arguments \fBfloat $x \fP The dividend 
.RE
.PP
\fBParameters\fP
.RS 4
\fI$y\fP 
.RE
.PP
The divisor 
.PP
\fBReturns\fP
.RS 4
float The floating point remainder of x/y 
.RE
.PP

.SS "get_cfg_var ( $option)"
Gets the value of a PHP configuration option \fBstring $option \fP The configuration option name\&. 
.PP
\fBReturns\fP
.RS 4
string the current value of the PHP configuration variable specified by option, or false if an error occurs\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "get_current_user ()"
Gets the name of the owner of the current PHP script \fBstring the username as a string\&.  4\&.0  5\&.0 \fP
.SS "get_magic_quotes_gpc ()"
Gets the current configuration setting of magic quotes gpc \fBint 0 if magic quotes gpc are off, 1 otherwise\&.  4\&.0  5\&.0  deprecated 266\&. \fP
.SS "get_magic_quotes_runtime ()"
Gets the current active configuration setting of magic_quotes_runtime \fBint 0 if magic quotes runtime is off, 1 otherwise\&.  4\&.0  5\&.0  deprecated 267\&. \fP
.SS "getenv ( $varname = \fC\fBnull\fP\fP,  $local_only = \fC\fBfalse\fP\fP)"
Gets the value of an environment variable \fBstring $varname [optional] \fP The variable name\&. 
.PP
\fBParameters\fP
.RS 4
\fI$local_only\fP [optional] 
.RE
.PP
Set to true to only return local environment variables (set by the operating system or putenv)\&. 
.PP
\fBReturns\fP
.RS 4
string|array|false the value of the environment variable varname or an associative array with all environment variables if no variable name is provided, or false on an error\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.5\&.38 The local_only parameter has been added\&. 
.PP
5\&.6\&.24 The local_only parameter has been added\&. 
.PP
7\&.0\&.9 The local_only parameter has been added\&. 
.PP
7\&.1 The varname parameter was made optional\&. 
.RE
.PP

.SS "getlastmod ()"
Gets time of last page modification \fBint the time of the last modification of the current page\&. The value returned is a Unix timestamp, suitable for feeding to date\&. Returns false on error\&.  4\&.0  5\&.0 \fP
.SS "getopt ( $options, array $longopts = \fC\fBnull\fP\fP, & $optind = \fC\fBnull\fP\fP)"
Gets options from the command line argument list \fBstring $options Each character in this string will be used as option characters and matched against options passed to the script starting with a single hyphen (-)\&. For example, an option string 'x' recognizes an option -x\&. Only a-z, A-Z and 0-9 are allowed\&.  array $longopts [optional] An array of options\&. Each element in this array will be used as option strings and matched against options passed to the script starting with two hyphens (--)\&. For example, an longopts element 'opt' recognizes an option --opt\&. Prior to PHP5\&.3\&.0 this parameter was only available on few systems  int $optind If the optind parameter is present, then the index where argument parsing stopped will be written to this variable\&.  array This function will return an array of option / argument pairs or false on failure\&.  4\&.3  5\&.0 \fP
.SS "getrusage ( $who = \fC\fBnull\fP\fP)"
Gets the current resource usages \fBint $who [optional] \fP If who is 1, getrusage will be called with RUSAGE_CHILDREN\&. 
.PP
\fBReturns\fP
.RS 4
array an associative array containing the data returned from the system call\&. All entries are accessible by using their documented field names\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "gettimeofday ( $return_float = \fC\fBnull\fP\fP)"
Get current time \fBbool $return_float [optional] \fP When set to true, a float instead of an array is returned\&. 
.PP
\fBReturns\fP
.RS 4
int[]|float By default an array is returned\&. If return_float is set, then a float is returned\&. 
.RE
.PP
.PP
Array keys: 'sec' - seconds since the Unix Epoch 'usec' - microseconds 'minuteswest' - minutes west of Greenwich 'dsttime' - type of dst correction 
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "hexdec ( $hex_string)"
Hexadecimal to decimal \fBstring $hex_string \fP The hexadecimal string to convert 
.PP
\fBReturns\fP
.RS 4
int|float The decimal representation of hex_string 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "hypot ( $x,  $y)"
Calculate the length of the hypotenuse of a right-angle triangle \fBfloat $x \fP Length of first side 
.PP
\fBParameters\fP
.RS 4
\fI$y\fP 
.RE
.PP
Length of second side 
.PP
\fBReturns\fP
.RS 4
float Calculated length of the hypotenuse 
.RE
.PP
\fBSince\fP
.RS 4
4\&.1 
.PP
5\&.0 
.RE
.PP

.SS "import_request_variables ( $types,  $prefix = \fC\fBnull\fP\fP)"
Import GET/POST/Cookie variables into the global scope \fBstring $types \fP Using the types parameter, you can specify which request variables to import\&. You can use 'G', 'P' and 'C' characters respectively for GET, POST and Cookie\&. These characters are not case sensitive, so you can also use any combination of 'g', 'p' and 'c'\&. POST includes the POST uploaded file information\&. 
.PP
Note that the order of the letters matters, as when using 'GP', the POST variables will overwrite GET variables with the same name\&. Any other letters than GPC are discarded\&. 
.PP
\fBParameters\fP
.RS 4
\fI$prefix\fP [optional] 
.RE
.PP
Variable name prefix, prepended before all variable's name imported into the global scope\&. So if you have a GET value named 'userid', and provide a prefix 'pref_', then you'll get a global variable named $pref_userid\&. 
.PP
Although the prefix parameter is optional, you will get an E_NOTICE level error if you specify no prefix, or specify an empty string as a prefix\&. This is a possible security hazard\&. Notice level errors are not displayed using the default error reporting level\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
5\&.3 This function has been DEPRECATED as of PHP 5\&.3\&.0 and REMOVED as of PHP 5\&.4\&.0\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.1 
.PP
5\&.0 
.RE
.PP

.SS "inet_ntop ( $in_addr)"
Converts a packed internet address to a human readable representation \fBstring $in_addr \fP \fBA\fP 32bit IPv4, or 128bit IPv6 address\&. 
.PP
\fBReturns\fP
.RS 4
string|false a string representation of the address or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.1 
.RE
.PP

.SS "inet_pton ( $address)"
Converts a human readable IP address to its packed in_addr representation \fBstring $address \fP \fBA\fP human readable IPv4 or IPv6 address\&. 
.PP
\fBReturns\fP
.RS 4
string the in_addr representation of the given address 
.RE
.PP
\fBSince\fP
.RS 4
5\&.1 
.RE
.PP

.SS "intdiv ( $dividend,  $divisor)"
Integer division \fB$dividend \fPNumber to be divided\&.
.PP
\fBParameters\fP
.RS 4
\fI$divisor\fP 
.RE
.PP
Number which divides the \fB\fIdividend\fP\fP
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP
If divisor is 0, a \fBDivisionByZeroError\fP exception is thrown\&. If the \fB\fIdividend\fP\fP is \fBPHP_INT_MIN\fP and the \fB\fIdivisor\fP\fP is -1, then an \fBArithmeticError\fP exception is thrown\&. 
.PP
\fBSince\fP
.RS 4
7\&.0 
.RE
.PP

.SS "ip2long ( $ip_address)"
Converts a string containing an (IPv4) Internet Protocol dotted address into a proper address \fBstring $ip_address \fP \fBA\fP standard format address\&. 
.PP
\fBReturns\fP
.RS 4
int|false the IPv4 address or false if ip_address is invalid\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "is_finite ( $val)"
Finds whether a value is a legal finite number \fBfloat $val \fP The value to check 
.PP
\fBReturns\fP
.RS 4
bool true if val is a legal finite number within the allowed range for a PHP float on this platform, else false\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "is_infinite ( $val)"
Finds whether a value is infinite \fBfloat $val \fP The value to check 
.PP
\fBReturns\fP
.RS 4
bool true if val is infinite, else false\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "is_nan ( $val)"
Finds whether a value is not a number \fBfloat $val \fP The value to check 
.PP
\fBReturns\fP
.RS 4
bool true if val is 'not a number', else false\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "log ( $arg,  $base = \fC\fBnull\fP\fP)"
Natural logarithm \fBfloat $arg \fP The value to calculate the logarithm for 
.PP
\fBParameters\fP
.RS 4
\fI$base\fP [optional] 
.RE
.PP
The optional logarithmic base to use (defaults to 'e' and so to the natural logarithm)\&. 
.PP
\fBReturns\fP
.RS 4
float The logarithm of arg to base, if given, or the natural logarithm\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "log10 ( $arg)"
Base-10 logarithm \fBfloat $arg \fP The argument to process 
.PP
\fBReturns\fP
.RS 4
float The base-10 logarithm of arg 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "log1p ( $number)"
Returns log(1 + number), computed in a way that is accurate even when 
.PP
\fBSince\fP
.RS 4
4\&.1 
.PP
5\&.0 the value of number is close to zero \fBfloat $number \fP The argument to process 
.RE
.PP
\fBReturns\fP
.RS 4
float log(1 + number) 
.RE
.PP

.SS "long2ip ( $proper_address)"
Converts an (IPv4) Internet network address into a string in Internet standard dotted format \fBstring|int $proper_address \fP \fBA\fP proper address representation\&. 
.PP
\fBReturns\fP
.RS 4
string the Internet IP address as a string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "magic_quotes_runtime ( $new_setting)"
<function>set_magic_quotes_runtime</function> \fBdeprecated 263\&. $new_setting  4\&.0  5\&.0 \fP
.SS "microtime ( $get_as_float = \fC\fBnull\fP\fP)"
Return current Unix timestamp with microseconds \fBbool $get_as_float [optional] \fP When called without the optional argument, this function returns the string 'msec sec' where sec is the current time measured in the number of seconds since the Unix Epoch (0:00:00 January 1, 1970 GMT), and msec is the microseconds part\&. Both portions of the string are returned in units of seconds\&. 
.PP
If the optional get_as_float is set to true then a float (in seconds) is returned\&. 
.PP
\fBReturns\fP
.RS 4
string|float 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "number_format ( $number,  $decimals = \fC0\fP,  $dec_point = \fC'\&.'\fP,  $thousands_sep = \fC','\fP)"
Format a number with grouped thousands \fBfloat $number \fP The number being formatted\&. 
.PP
\fBParameters\fP
.RS 4
\fI$decimals\fP [optional] 
.RE
.PP
Sets the number of decimal points\&. 
.PP
\fBParameters\fP
.RS 4
\fI$dec_point\fP [optional] 
.br
\fI$thousands_sep\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
string \fBA\fP formatted version of number\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "octdec ( $octal_string)"
Octal to decimal \fBstring $octal_string \fP The octal string to convert 
.PP
\fBReturns\fP
.RS 4
int|float The decimal representation of octal_string 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "pi ()"
Get value of pi \fBfloat The value of pi as float\&.  4\&.0  5\&.0 \fP
.SS "pow ( $base,  $exp)"
Exponential expression \fBint|float $base \fP The base to use 
.PP
\fBParameters\fP
.RS 4
\fI$exp\fP 
.RE
.PP
The exponent 
.PP
\fBReturns\fP
.RS 4
int|float base raised to the power of exp\&. If the result can be represented as integer it will be returned as type integer, else it will be returned as type float\&. If the power cannot be computed false will be returned instead\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "putenv ( $setting)"
Sets the value of an environment variable \fBstring $setting \fP The setting, like 'FOO=BAR' 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "quoted_printable_decode ( $str)"
Convert a quoted-printable string to an 8 bit string \fBstring $str \fP The input string\&. 
.PP
\fBReturns\fP
.RS 4
string the 8-bit binary string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "quoted_printable_encode ( $str)"
Convert a 8 bit string to a quoted-printable string \fBstring $str \fP The input string\&. 
.PP
\fBReturns\fP
.RS 4
string the encoded string\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.3 
.RE
.PP

.SS "rad2deg ( $number)"
Converts the radian number to the equivalent number in degrees \fBfloat $number \fP \fBA\fP radian value 
.PP
\fBReturns\fP
.RS 4
float The equivalent of number in degrees 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "round ( $val,  $precision = \fC0\fP,  $mode = \fC\fBPHP_ROUND_HALF_UP\fP\fP)"
Returns the rounded value of val to specified precision (number of digits after the decimal point)\&. precision can also be negative or zero (default)\&. Note: PHP doesn't handle strings like '12,300\&.2' correctly by default\&. See converting from strings\&. \fBfloat $val \fP The value to round 
.PP
\fBParameters\fP
.RS 4
\fI$precision\fP [optional] 
.RE
.PP
The optional number of decimal digits to round to\&. 
.PP
\fBParameters\fP
.RS 4
\fI$mode\fP [optional] 
.RE
.PP
One of PHP_ROUND_HALF_UP, PHP_ROUND_HALF_DOWN, PHP_ROUND_HALF_EVEN, or PHP_ROUND_HALF_ODD\&. 
.PP
\fBReturns\fP
.RS 4
float|false The rounded value 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "set_magic_quotes_runtime ( $new_setting)"
Sets the current active configuration setting of magic_quotes_runtime \fBdeprecated 264\&. bool $new_setting \fP false for off, true for on\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
5\&.4 This function has been DEPRECATED as of PHP 5\&.4\&.0\&. Raises an E_CORE_ERROR\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "set_time_limit ( $seconds)"
Limits the maximum execution time \fBint $seconds \fP The maximum execution time, in seconds\&. If set to zero, no time limit is imposed\&. 
.PP
\fBReturns\fP
.RS 4
bool Returns TRUE on success, or FALSE on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "sin ( $arg)"
Sine \fBfloat $arg \fP \fBA\fP value in radians 
.PP
\fBReturns\fP
.RS 4
float The sine of arg 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "sinh ( $arg)"
Hyperbolic sine \fBfloat $arg \fP The argument to process 
.PP
\fBReturns\fP
.RS 4
float The hyperbolic sine of arg 
.RE
.PP
\fBSince\fP
.RS 4
4\&.1 
.PP
5\&.0 
.RE
.PP

.SS "sqrt ( $arg)"
Square root \fBfloat $arg \fP The argument to process 
.PP
\fBReturns\fP
.RS 4
float The square root of arg or the special value NAN for negative numbers\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "sys_getloadavg ()"
Gets system load average \fBarray an array with three samples (last 1, 5 and 15 minutes)\&.  5\&.1\&.3 \fP
.SS "tan ( $arg)"
Tangent \fBfloat $arg \fP The argument to process in radians 
.PP
\fBReturns\fP
.RS 4
float The tangent of arg 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "tanh ( $arg)"
Hyperbolic tangent \fBfloat $arg \fP The argument to process 
.PP
\fBReturns\fP
.RS 4
float The hyperbolic tangent of arg 
.RE
.PP
\fBSince\fP
.RS 4
4\&.1 
.PP
5\&.0 
.RE
.PP

.SS "uniqid ( $prefix = \fC''\fP,  $more_entropy = \fC\fBfalse\fP\fP)"
Generate a unique ID \fBstring $prefix [optional] \fP Can be useful, for instance, if you generate identifiers simultaneously on several hosts that might happen to generate the identifier at the same microsecond\&. 
.PP
With an empty prefix, the returned string will be 13 characters long\&. If more_entropy is true, it will be 23 characters\&. 
.PP
\fBParameters\fP
.RS 4
\fI$more_entropy\fP [optional] 
.RE
.PP
If set to true, uniqid will add additional entropy (using the combined linear congruential generator) at the end of the return value, which should make the results more unique\&. 
.PP
\fBReturns\fP
.RS 4
string the unique identifier, as a string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Safaricom SDP from the source code\&.
