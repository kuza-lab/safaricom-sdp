.TH "vendor/jetbrains/phpstorm-stubs/gmp/gmp.php" 3 "Sat Sep 26 2020" "Safaricom SDP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
vendor/jetbrains/phpstorm-stubs/gmp/gmp.php
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBGMP\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBgmp_init\fP ($number, $base=0)"
.br
.ti -1c
.RI "\fBgmp_intval\fP ($gmpnumber)"
.br
.ti -1c
.RI "\fBgmp_random_seed\fP ($seed)"
.br
.ti -1c
.RI "\fBgmp_strval\fP ($gmpnumber, $base=10)"
.br
.ti -1c
.RI "\fBgmp_add\fP ($\fBa\fP, $\fBb\fP)"
.br
.ti -1c
.RI "\fBgmp_sub\fP ($\fBa\fP, $\fBb\fP)"
.br
.ti -1c
.RI "\fBgmp_mul\fP ($\fBa\fP, $\fBb\fP)"
.br
.ti -1c
.RI "\fBgmp_div_qr\fP ($\fBn\fP, $d, $\fBround\fP=\fBGMP_ROUND_ZERO\fP)"
.br
.ti -1c
.RI "\fBgmp_div_q\fP ($\fBa\fP, $\fBb\fP, $\fBround\fP=\fBGMP_ROUND_ZERO\fP)"
.br
.ti -1c
.RI "\fBgmp_div_r\fP ($\fBn\fP, $d, $\fBround\fP=\fBGMP_ROUND_ZERO\fP)"
.br
.ti -1c
.RI "\fBgmp_div\fP ($\fBa\fP, $\fBb\fP, $\fBround\fP=\fBGMP_ROUND_ZERO\fP)"
.br
.ti -1c
.RI "\fBgmp_mod\fP ($\fBn\fP, $d)"
.br
.ti -1c
.RI "\fBgmp_divexact\fP ($\fBn\fP, $d)"
.br
.ti -1c
.RI "\fBgmp_neg\fP ($\fBa\fP)"
.br
.ti -1c
.RI "\fBgmp_abs\fP ($\fBa\fP)"
.br
.ti -1c
.RI "\fBgmp_fact\fP ($\fBa\fP)"
.br
.ti -1c
.RI "\fBgmp_sqrt\fP ($\fBa\fP)"
.br
.ti -1c
.RI "\fBgmp_sqrtrem\fP ($\fBa\fP)"
.br
.ti -1c
.RI "\fBgmp_pow\fP ($base, $\fBexp\fP)"
.br
.ti -1c
.RI "\fBgmp_powm\fP ($base, $\fBexp\fP, $mod)"
.br
.ti -1c
.RI "\fBgmp_perfect_square\fP ($\fBa\fP)"
.br
.ti -1c
.RI "\fBgmp_prob_prime\fP ($\fBa\fP, $reps=10)"
.br
.ti -1c
.RI "\fBgmp_random_bits\fP ($bits)"
.br
.ti -1c
.RI "\fBgmp_random_range\fP (\fBGMP\fP $\fBmin\fP, \fBGMP\fP $\fBmax\fP)"
.br
.ti -1c
.RI "\fBgmp_gcd\fP ($\fBa\fP, $\fBb\fP)"
.br
.ti -1c
.RI "\fBgmp_gcdext\fP ($\fBa\fP, $\fBb\fP)"
.br
.ti -1c
.RI "\fBgmp_invert\fP ($\fBa\fP, $\fBb\fP)"
.br
.ti -1c
.RI "\fBgmp_jacobi\fP ($\fBa\fP, $p)"
.br
.ti -1c
.RI "\fBgmp_legendre\fP ($\fBa\fP, $p)"
.br
.ti -1c
.RI "\fBgmp_cmp\fP ($\fBa\fP, $\fBb\fP)"
.br
.ti -1c
.RI "\fBgmp_sign\fP ($\fBa\fP)"
.br
.ti -1c
.RI "\fBgmp_random\fP ($limiter=20)"
.br
.ti -1c
.RI "\fBgmp_and\fP ($\fBa\fP, $\fBb\fP)"
.br
.ti -1c
.RI "\fBgmp_or\fP ($\fBa\fP, $\fBb\fP)"
.br
.ti -1c
.RI "\fBgmp_com\fP ($\fBa\fP)"
.br
.ti -1c
.RI "\fBgmp_xor\fP ($\fBa\fP, $\fBb\fP)"
.br
.ti -1c
.RI "\fBgmp_setbit\fP (&$\fBa\fP, $index, $set_clear=\fBtrue\fP)"
.br
.ti -1c
.RI "\fBgmp_clrbit\fP (&$\fBa\fP, $index)"
.br
.ti -1c
.RI "\fBgmp_scan0\fP ($\fBa\fP, $start)"
.br
.ti -1c
.RI "\fBgmp_scan1\fP ($\fBa\fP, $start)"
.br
.ti -1c
.RI "\fBgmp_testbit\fP ($\fBa\fP, $index)"
.br
.ti -1c
.RI "\fBgmp_popcount\fP ($\fBa\fP)"
.br
.ti -1c
.RI "\fBgmp_hamdist\fP ($\fBa\fP, $\fBb\fP)"
.br
.ti -1c
.RI "\fBgmp_import\fP ($data, $word_size=1, $options=\fBGMP_MSW_FIRST\fP|\fBGMP_NATIVE_ENDIAN\fP)"
.br
.ti -1c
.RI "\fBgmp_export\fP (\fBGMP\fP $gmpnumber, $word_size=1, $options=\fBGMP_MSW_FIRST\fP|\fBGMP_NATIVE_ENDIAN\fP)"
.br
.ti -1c
.RI "\fBgmp_root\fP (\fBGMP\fP $\fBa\fP, $nth)"
.br
.ti -1c
.RI "\fBgmp_rootrem\fP (\fBGMP\fP $\fBa\fP, $nth)"
.br
.ti -1c
.RI "\fBgmp_nextprime\fP ($\fBa\fP)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBGMP_ROUND_ZERO\fP 0"
.br
.ti -1c
.RI "const \fBGMP_ROUND_PLUSINF\fP 1"
.br
.ti -1c
.RI "const \fBGMP_ROUND_MINUSINF\fP 2"
.br
.ti -1c
.RI "const \fBGMP_MSW_FIRST\fP 1"
.br
.ti -1c
.RI "const \fBGMP_LSW_FIRST\fP 2"
.br
.ti -1c
.RI "const \fBGMP_LITTLE_ENDIAN\fP 4"
.br
.ti -1c
.RI "const \fBGMP_BIG_ENDIAN\fP 8"
.br
.ti -1c
.RI "const \fBGMP_NATIVE_ENDIAN\fP 16"
.br
.ti -1c
.RI "const \fBGMP_VERSION\fP ''"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "gmp_abs ( $a)"
Absolute value \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBReturns\fP
.RS 4
resource|GMP the absolute value of \fIa\fP, as a \fBGMP\fP number\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_add ( $a,  $b)"
Add numbers \fBresource|string|GMP $a \fP \fBA\fP number that will be added\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$b\fP 
.RE
.PP
\fBA\fP number that will be added\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number representing the sum of the arguments\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_and ( $a,  $b)"
Bitwise AND \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$b\fP It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.RE
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number representing the bitwise AND comparison\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_clrbit (& $a,  $index)"
Clear bit \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$index\fP It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.RE
.PP
\fBReturns\fP
.RS 4
void \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_cmp ( $a,  $b)"
Compare numbers \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$b\fP It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.RE
.PP
\fBReturns\fP
.RS 4
int a positive value if a > b, zero if a = b and a negative value if a < b\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_com ( $a)"
Calculates one's complement \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBReturns\fP
.RS 4
resource|GMP the one's complement of \fIa\fP, as a \fBGMP\fP number\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_div ( $a,  $b,  $round = \fC\fBGMP_ROUND_ZERO\fP\fP)"
Divide numbers \fBresource|string|GMP $a \fP The number being divided\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$b\fP 
.RE
.PP
The number that \fIa\fP is being divided by\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$round\fP [optional] 
.RE
.PP
The result rounding is defined by the \fIround\fP, which can have the following values: \fBGMP_ROUND_ZERO\fP: The result is truncated towards 0\&. 
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_div_q ( $a,  $b,  $round = \fC\fBGMP_ROUND_ZERO\fP\fP)"
Divide numbers \fBresource|string|GMP $a \fP The number being divided\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$b\fP 
.RE
.PP
The number that \fIa\fP is being divided by\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$round\fP [optional] 
.RE
.PP
The result rounding is defined by the \fIround\fP, which can have the following values: \fBGMP_ROUND_ZERO\fP: The result is truncated towards 0\&. 
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_div_qr ( $n,  $d,  $round = \fC\fBGMP_ROUND_ZERO\fP\fP)"
Divide numbers and get quotient and remainder \fBresource|string|GMP $n \fP The number being divided\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$d\fP 
.RE
.PP
The number that \fIn\fP is being divided by\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$round\fP [optional] 
.RE
.PP
See the \fBgmp_div_q\fP function for description of the \fIround\fP argument\&. 
.PP
\fBReturns\fP
.RS 4
array an array, with the first element being [n/d] (the integer result of the division) and the second being (n - [n/d] * d) (the remainder of the division)\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_div_r ( $n,  $d,  $round = \fC\fBGMP_ROUND_ZERO\fP\fP)"
Remainder of the division of numbers \fBresource|string|GMP $n \fP The number being divided\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$d\fP 
.RE
.PP
The number that \fIn\fP is being divided by\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$round\fP [optional] 
.RE
.PP
See the \fBgmp_div_q\fP function for description of the \fIround\fP argument\&. 
.PP
\fBReturns\fP
.RS 4
resource|GMP The remainder, as a \fBGMP\fP number\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_divexact ( $n,  $d)"
Exact division of numbers \fBresource|string|GMP $n \fP The number being divided\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$d\fP 
.RE
.PP
The number that \fIa\fP is being divided by\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_export (\fBGMP\fP $gmpnumber,  $word_size = \fC1\fP,  $options = \fC\fBGMP_MSW_FIRST\fP | \fBGMP_NATIVE_ENDIAN\fP\fP)"
Export to a binary string \fBGMP $gmpnumber The GMP number being exported  integer $word_size Default value is 1\&. The number of bytes in each chunk of binary data\&. This is mainly used in conjunction with the options parameter\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$options\fP Default value is GMP_MSW_FIRST | GMP_NATIVE_ENDIAN\&. 
.RE
.PP
\fBReturns\fP
.RS 4
string|false Returns a string or FALSE on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.6\&.1 
.RE
.PP

.SS "gmp_fact ( $a)"
Factorial \fBresource|string|GMP $a \fP The factorial number\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_gcd ( $a,  $b)"
Calculate GCD \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$b\fP It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.RE
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP positive \fBGMP\fP number that divides into both \fIa\fP and \fIb\fP\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_gcdext ( $a,  $b)"
Calculate GCD and multipliers \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$b\fP It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.RE
.PP
\fBReturns\fP
.RS 4
array An array of \fBGMP\fP numbers\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_hamdist ( $a,  $b)"
Hamming distance \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
It should be positive\&. 
.PP
\fBParameters\fP
.RS 4
\fI$b\fP It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.RE
.PP
.PP
It should be positive\&. 
.PP
\fBReturns\fP
.RS 4
int \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_import ( $data,  $word_size = \fC1\fP,  $options = \fC\fBGMP_MSW_FIRST\fP | \fBGMP_NATIVE_ENDIAN\fP\fP)"
Import from a binary string \fBstring $data The binary string being imported  integer $word_size Default value is 1\&. The number of bytes in each chunk of binary data\&. This is mainly used in conjunction with the options parameter\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$options\fP Default value is GMP_MSW_FIRST | GMP_NATIVE_ENDIAN\&. 
.RE
.PP
\fBReturns\fP
.RS 4
GMP|false Returns a \fBGMP\fP number or FALSE on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.6\&.1 
.RE
.PP

.SS "gmp_init ( $number,  $base = \fC0\fP)"
Create \fBGMP\fP number \fBmixed $number \fP An integer or a string\&. The string representation can be decimal, hexadecimal or octal\&. 
.PP
\fBParameters\fP
.RS 4
\fI$base\fP [optional] 
.RE
.PP
The base\&. 
.PP
The base may vary from 2 to 36\&. If base is 0 (default value), the actual base is determined from the leading characters: if the first two characters are 0x or 0X, hexadecimal is assumed, otherwise if the first character is '0', octal is assumed, otherwise decimal is assumed\&. 
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_intval ( $gmpnumber)"
Convert \fBGMP\fP number to integer \fBresource|string|GMP $gmpnumber \fP \fBA\fP \fBGMP\fP number\&. 
.PP
\fBReturns\fP
.RS 4
int An integer value of \fIgmpnumber\fP\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_invert ( $a,  $b)"
Inverse by modulo \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$b\fP It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.RE
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number on success or \fBFALSE\fP if an inverse does not exist\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_jacobi ( $a,  $p)"
Jacobi symbol \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$p\fP It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.RE
.PP
.PP
Should be odd and must be positive\&. 
.PP
\fBReturns\fP
.RS 4
int \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_legendre ( $a,  $p)"
Legendre symbol \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$p\fP It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.RE
.PP
.PP
Should be odd and must be positive\&. 
.PP
\fBReturns\fP
.RS 4
int \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_mod ( $n,  $d)"
Modulo operation \fBresource|string|GMP $n It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$d\fP 
.RE
.PP
The modulo that is being evaluated\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_mul ( $a,  $b)"
Multiply numbers \fBresource|string|GMP $a \fP \fBA\fP number that will be multiplied by \fIb\fP\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$b\fP 
.RE
.PP
\fBA\fP number that will be multiplied by \fIa\fP\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_neg ( $a)"
Negate number \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBReturns\fP
.RS 4
resource|GMP -\fIa\fP, as a \fBGMP\fP number\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_nextprime ( $a)"
Find next prime number \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBReturns\fP
.RS 4
resource Return the next prime number greater than \fIa\fP, as a \fBGMP\fP number\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.2 
.RE
.PP

.SS "gmp_or ( $a,  $b)"
Bitwise OR \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$b\fP It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.RE
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_perfect_square ( $a)"
Perfect square check \fBresource|string|GMP $a \fP The number being checked as a perfect square\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
bool \fBTRUE\fP if \fIa\fP is a perfect square, \fBFALSE\fP otherwise\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_popcount ( $a)"
Population count \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBReturns\fP
.RS 4
int The population count of \fIa\fP, as an integer\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_pow ( $base,  $exp)"
Raise number into power \fBresource|string|GMP $base \fP The base number\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$exp\fP 
.RE
.PP
The positive power to raise the \fIbase\fP\&. 
.PP
\fBReturns\fP
.RS 4
resource|GMP The new (raised) number, as a \fBGMP\fP number\&. The case of 0^0 yields 1\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_powm ( $base,  $exp,  $mod)"
Raise number into power with modulo \fBresource|string|GMP $base \fP The base number\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$exp\fP 
.RE
.PP
The positive power to raise the \fIbase\fP\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$mod\fP 
.RE
.PP
The modulo\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
resource|GMP The new (raised) number, as a \fBGMP\fP number\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_prob_prime ( $a,  $reps = \fC10\fP)"
Check if number is 'probably prime' \fBresource|string|GMP $a \fP The number being checked as a prime\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$reps\fP [optional] 
.RE
.PP
Reasonable values of \fIreps\fP vary from 5 to 10 (default being 10); a higher value lowers the probability for a non-prime to pass as a 'probable' prime\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
int If this function returns 0, \fIa\fP is definitely not prime\&. If it returns 1, then \fIa\fP is 'probably' prime\&. If it returns 2, then \fIa\fP is surely prime\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_random ( $limiter = \fC20\fP)"
Random number \fBint $limiter [optional] \fP The limiter\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP random \fBGMP\fP number\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.2 Use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBgmp_random_bits()\fP} or {
.PP
\fBgmp_random_range()\fP} instead\&. 
.RE
.PP

.SS "gmp_random_bits ( $bits)"
Random number \fBint $bits \fPThe number of bits\&. Either a \fBGMP\fP number resource in PHP 5\&.5 and earlier, a \fBGMP\fP object in PHP 5\&.6 and later, or a numeric string provided that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
\fBGMP\fP \fBA\fP random \fBGMP\fP number\&. 
.RE
.PP

.SS "gmp_random_range (\fBGMP\fP $min, \fBGMP\fP $max)"
Random number \fBGMP $min \fP\fBA\fP \fBGMP\fP number representing the lower bound for the random number
.PP
\fBParameters\fP
.RS 4
\fI$max\fP 
.RE
.PP
\fBA\fP \fBGMP\fP number representing the upper bound for the random number
.PP
\fBReturns\fP
.RS 4
\fBGMP\fP \fBA\fP random \fBGMP\fP number\&. 
.RE
.PP

.SS "gmp_random_seed ( $seed)"
Sets the RNG seed 
.PP
\fBParameters\fP
.RS 4
\fI$seed\fP 
.RE
.PP
The seed to be set for the {
.PP
\fBSee also\fP
.RS 4
\fBgmp_random()\fP}, {
.PP
\fBgmp_random_bits()\fP}, and {
.PP
\fBgmp_random_range()\fP} functions\&. 
.RE
.PP
Either a \fBGMP\fP number resource in PHP 5\&.5 and earlier, a \fBGMP\fP object in PHP 5\&.6 and later, or a numeric string provided that it is possible to convert the latter to a number\&. 
.PP
\fBReturns\fP
.RS 4
mixed Returns NULL on success\&. 
.RE
.PP
\fBSince\fP
.RS 4
7\&.0 
.RE
.PP

.SS "gmp_root (\fBGMP\fP $a,  $nth)"
Takes the nth root of a and returns the integer component of the result\&. \fBGMP $a Either a GMP number resource in PHP 5\&.5 and earlier, a GMP object in PHP 5\&.6 and later, or a numeric string provided that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$nth\fP The positive root to take of a\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBGMP\fP The integer component of the resultant root, as a \fBGMP\fP number\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.6 
.RE
.PP

.SS "gmp_rootrem (\fBGMP\fP $a,  $nth)"
Takes the nth root of a and returns the integer component and remainder of the result\&. \fBGMP $a Either a GMP number resource in PHP 5\&.5 and earlier, a GMP object in PHP 5\&.6 and later, or a numeric string provided that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$nth\fP The positive root to take of a\&. 
.RE
.PP
\fBReturns\fP
.RS 4
array|GMP[] \fBA\fP two element array, where the first element is the integer component of the root, and the second element is the remainder, both represented as \fBGMP\fP numbers\&.
.RE
.PP
\fBSince\fP
.RS 4
5\&.6 
.RE
.PP

.SS "gmp_scan0 ( $a,  $start)"
Scan for 0 \fBresource|string|GMP $a \fP The number to scan\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$start\fP 
.RE
.PP
The starting bit\&. 
.PP
\fBReturns\fP
.RS 4
int the index of the found bit, as an integer\&. The index starts from 0\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_scan1 ( $a,  $start)"
Scan for 1 \fBresource|string|GMP $a \fP The number to scan\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$start\fP 
.RE
.PP
The starting bit\&. 
.PP
\fBReturns\fP
.RS 4
int the index of the found bit, as an integer\&. If no set bit is found, -1 is returned\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_setbit (& $a,  $index,  $set_clear = \fC\fBtrue\fP\fP)"
Set bit \fBresource|string|GMP $a \fP The number being set to\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$index\fP 
.RE
.PP
The set bit\&. 
.PP
\fBParameters\fP
.RS 4
\fI$set_clear\fP [optional] 
.RE
.PP
Defines if the bit is set to 0 or 1\&. By default the bit is set to
.IP "1." 4
Index starts at 0\&. 
.PP
.PP
\fBReturns\fP
.RS 4
void \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_sign ( $a)"
Sign of number \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBReturns\fP
.RS 4
int 1 if \fIa\fP is positive, -1 if \fIa\fP is negative, and 0 if \fIa\fP is zero\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_sqrt ( $a)"
Calculate square root \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBReturns\fP
.RS 4
resource|GMP The integer portion of the square root, as a \fBGMP\fP number\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_sqrtrem ( $a)"
Square root with remainder \fBresource|string|GMP $a \fP The number being square rooted\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
array array where first element is the integer square root of \fIa\fP and the second is the remainder (i\&.e\&., the difference between \fIa\fP and the first element squared)\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_strval ( $gmpnumber,  $base = \fC10\fP)"
Convert \fBGMP\fP number to string \fBresource|string|GMP $gmpnumber \fP The \fBGMP\fP number that will be converted to a string\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$base\fP [optional] 
.RE
.PP
The base of the returned number\&. The default base is 10\&. Allowed values for the base are from 2 to 62 and -2 to -36\&. 
.PP
\fBReturns\fP
.RS 4
string The number, as a string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_sub ( $a,  $b)"
Subtract numbers \fBresource|string|GMP $a \fP The number being subtracted from\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBParameters\fP
.RS 4
\fI$b\fP 
.RE
.PP
The number subtracted from \fIa\fP\&. 
.PP
It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SS "gmp_testbit ( $a,  $index)"
Tests if a bit is set \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$index\fP 
.RE
.PP
The bit to test 
.PP
\fBReturns\fP
.RS 4
bool \fBTRUE\fP on success or \fBFALSE\fP on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.3 
.RE
.PP

.SS "gmp_xor ( $a,  $b)"
Bitwise XOR \fBresource|string|GMP $a It can be either a GMP number resource, or a numeric string given that it is possible to convert the latter to a number\&.\fP 
.PP
\fBParameters\fP
.RS 4
\fI$b\fP It can be either a \fBGMP\fP number resource, or a numeric string given that it is possible to convert the latter to a number\&.
.RE
.PP
\fBReturns\fP
.RS 4
resource|GMP \fBA\fP \fBGMP\fP number resource\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.4 
.PP
5\&.0 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "const GMP_BIG_ENDIAN 8"

.SS "const GMP_LITTLE_ENDIAN 4"

.SS "const GMP_LSW_FIRST 2"

.SS "const GMP_MSW_FIRST 1"

.SS "const GMP_NATIVE_ENDIAN 16"

.SS "const GMP_ROUND_MINUSINF 2"

.SS "const GMP_ROUND_PLUSINF 1"

.SS "const GMP_ROUND_ZERO 0"

.SS "const GMP_VERSION ''"
The \fBGMP\fP library version \fBhttps://php\&.net/manual/en/gmp\&.constants\&.php\fP
.SH "Author"
.PP 
Generated automatically by Doxygen for Safaricom SDP from the source code\&.
