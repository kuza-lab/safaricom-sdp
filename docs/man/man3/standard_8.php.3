.TH "vendor/jetbrains/phpstorm-stubs/standard/standard_8.php" 3 "Sat Sep 26 2020" "Safaricom SDP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
vendor/jetbrains/phpstorm-stubs/standard/standard_8.php
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBsyslog\fP ($priority, $message)"
.br
.ti -1c
.RI "\fBcloselog\fP ()"
.br
.ti -1c
.RI "\fBheader_register_callback\fP (callable $\fBcallback\fP)"
.br
.ti -1c
.RI "\fBgetimagesizefromstring\fP ($imagedata, array &$imageinfo=\fBnull\fP)"
.br
.ti -1c
.RI "\fBstream_set_chunk_size\fP ($fp, $chunk_size)"
.br
.ti -1c
.RI "\fBdefine_syslog_variables\fP ()"
.br
.ti -1c
.RI "\fBlcg_value\fP ()"
.br
.ti -1c
.RI "\fBmetaphone\fP ($str, $phonemes=0)"
.br
.ti -1c
.RI "\fBob_start\fP ($output_callback=\fBnull\fP, $chunk_size=\fBnull\fP, $erase=\fBnull\fP)"
.br
.ti -1c
.RI "\fBob_flush\fP ()"
.br
.ti -1c
.RI "\fBob_clean\fP ()"
.br
.ti -1c
.RI "\fBob_end_flush\fP ()"
.br
.ti -1c
.RI "\fBob_end_clean\fP ()"
.br
.ti -1c
.RI "\fBob_get_flush\fP ()"
.br
.ti -1c
.RI "\fBob_get_clean\fP ()"
.br
.ti -1c
.RI "\fBob_get_length\fP ()"
.br
.ti -1c
.RI "\fBob_get_level\fP ()"
.br
.ti -1c
.RI "\fBob_get_status\fP ($full_status=\fBnull\fP)"
.br
.ti -1c
.RI "\fBob_get_contents\fP ()"
.br
.ti -1c
.RI "\fBob_implicit_flush\fP ($flag=1)"
.br
.ti -1c
.RI "\fBob_list_handlers\fP ()"
.br
.ti -1c
.RI "\fBksort\fP (array &$array, $sort_flags=\fBnull\fP)"
.br
.ti -1c
.RI "\fBkrsort\fP (array &$array, $sort_flags=\fBnull\fP)"
.br
.ti -1c
.RI "\fBnatsort\fP (array &$array)"
.br
.ti -1c
.RI "\fBnatcasesort\fP (array &$array)"
.br
.ti -1c
.RI "\fBasort\fP (array &$array, $sort_flags=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarsort\fP (array &$array, $sort_flags=\fBnull\fP)"
.br
.ti -1c
.RI "\fBsort\fP (array &$array, $sort_flags=\fBnull\fP)"
.br
.ti -1c
.RI "\fBrsort\fP (array &$array, $sort_flags=\fBnull\fP)"
.br
.ti -1c
.RI "\fBusort\fP (array &$array, $cmp_function)"
.br
.ti -1c
.RI "\fBuasort\fP (array &$array, $cmp_function)"
.br
.ti -1c
.RI "\fBuksort\fP (array &$array, $cmp_function)"
.br
.ti -1c
.RI "\fBshuffle\fP (array &$array)"
.br
.ti -1c
.RI "\fBarray_walk\fP (array &$array, $funcname, $userdata=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_walk_recursive\fP (array &$input, $funcname, $userdata=\fBnull\fP)"
.br
.ti -1c
.RI "\fBcount\fP ($var, $mode=\fBCOUNT_NORMAL\fP)"
.br
.ti -1c
.RI "\fBend\fP (array &$array)"
.br
.ti -1c
.RI "\fBprev\fP (array &$array)"
.br
.ti -1c
.RI "\fBnext\fP (array &$array)"
.br
.ti -1c
.RI "\fBreset\fP (array &$array)"
.br
.ti -1c
.RI "\fBcurrent\fP (array $array)"
.br
.ti -1c
.RI "\fBkey\fP (array $array)"
.br
.ti -1c
.RI "\fBmin\fP ($value1, $value2=\fBnull\fP,\&.\&.\&. $values)"
.br
.ti -1c
.RI "\fBmax\fP ($value1, $value2=\fBnull\fP,\&.\&.\&. $values)"
.br
.ti -1c
.RI "\fBin_array\fP ($needle, array $haystack, $strict=\fBfalse\fP)"
.br
.ti -1c
.RI "\fBarray_search\fP ($needle, array $haystack, $strict=\fBnull\fP)"
.br
.ti -1c
.RI "\fBextract\fP (array $var_array, $extract_type=\fBnull\fP, $prefix=\fBnull\fP)"
.br
.ti -1c
.RI "\fBcompact\fP ($varname, $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_fill\fP ($start_index, $num, $value)"
.br
.ti -1c
.RI "\fBarray_fill_keys\fP (array $keys, $value)"
.br
.ti -1c
.RI "\fBrange\fP ($start, $\fBend\fP, $step=1)"
.br
.ti -1c
.RI "\fBarray_multisort\fP (array &$array1, $array1_sort_order=\fBnull\fP, $array1_sort_flags=\fBnull\fP, $\fB_\fP=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_push\fP (array &$array,\&.\&.\&. $vars)"
.br
.ti -1c
.RI "\fBarray_pop\fP (array &$array)"
.br
.ti -1c
.RI "\fBarray_shift\fP (array &$array)"
.br
.ti -1c
.RI "\fBarray_unshift\fP (array &$array,\&.\&.\&. $vars)"
.br
.ti -1c
.RI "\fBarray_splice\fP (array &$input, $offset, $length=\fBnull\fP, $replacement=\fBnull\fP)"
.br
.ti -1c
.RI "\fBarray_slice\fP (array $array, $offset, $length=\fBnull\fP, $preserve_keys=\fBfalse\fP)"
.br
.ti -1c
.RI "\fBarray_merge\fP (array $array1, array $array2=\fBnull\fP, array $\fB_\fP=\fBnull\fP)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "array_fill ( $start_index,  $num,  $value)"
Fill an array with values \fBint $start_index \fP The first index of the returned array\&. Supports non-negative indexes only\&. 
.PP
\fBParameters\fP
.RS 4
\fI$num\fP 
.RE
.PP
Number of elements to insert 
.PP
\fBParameters\fP
.RS 4
\fI$value\fP 
.RE
.PP
Value to use for filling 
.PP
\fBReturns\fP
.RS 4
array the filled array 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "array_fill_keys (array $keys,  $value)"
Fill an array with values, specifying keys \fBarray $keys \fP Array of values that will be used as keys\&. Illegal values for key will be converted to string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$value\fP 
.RE
.PP
Value to use for filling 
.PP
\fBReturns\fP
.RS 4
array the filled array 
.RE
.PP
\fBSince\fP
.RS 4
5\&.2 
.RE
.PP

.SS "array_merge (array $array1, array $array2 = \fC\fBnull\fP\fP, array $_ = \fC\fBnull\fP\fP)"
Merge one or more arrays \fBarray $array1 \fP Initial array to merge\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array2\fP [optional] 
.br
\fI$_\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
array the resulting array\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.PP
\fBExamples\fP
.in +1c
\fB/usr/local/var/www/safaricom\-sdp\-sdk/vendor/roave/better\-reflection/src/Reflection/ReflectionClass\&.php\fP\&.
.SS "array_multisort (array & $array1,  $array1_sort_order = \fC\fBnull\fP\fP,  $array1_sort_flags = \fC\fBnull\fP\fP,  $_ = \fC\fBnull\fP\fP)"
Sort multiple or multi-dimensional arrays \fBarray $array1 \fP An array being sorted\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array1_sort_order\fP [optional] 
.RE
.PP
The order used to sort the previous array argument\&. Either SORT_ASC to sort ascendingly or SORT_DESC to sort descendingly\&. This argument can be swapped with array1_sort_flags or omitted entirely, in which case SORT_ASC is assumed\&. 
.PP
\fBParameters\fP
.RS 4
\fI$array1_sort_flags\fP [optional] 
.RE
.PP
Sort options for the previous array argument: Sorting type flags: SORT_REGULAR - compare items normally (don't change types) SORT_NUMERIC - compare items numerically SORT_STRING - compare items as strings SORT_LOCALE_STRING - compare items as strings, based on the current locale\&. It uses the locale, which can be changed using \fBsetlocale()\fP SORT_NATURAL - compare items as strings using 'natural ordering' like \fBnatsort()\fP SORT_FLAG_CASE - can be combined (bitwise OR) with SORT_STRING or SORT_NATURAL to sort strings case-insensitively This argument can be swapped with array1_sort_order or omitted entirely, in which case SORT_REGULAR is assumed\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.RE
.PP
More arrays, optionally followed by sort order and flags\&. Only elements corresponding to equivalent elements in previous arrays are compared\&. In other words, the sort is lexicographical\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "array_pop (array & $array)"
Pop the element off the end of array \fBarray $array \fP The array to get the value from\&. 
.PP
\fBReturns\fP
.RS 4
mixed the last value of array\&. If array is empty (or is not an array),  will be returned\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "array_push (array & $array,  $vars)"
Push elements onto the end of array \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$vars\fP [optional] 
.RE
.PP
The pushed variables\&. 
.PP
\fBReturns\fP
.RS 4
int the number of elements in the array\&. 
.RE
.PP
\fBSince\fP
.RS 4
7\&.3 
.RE
.PP

.SS "array_search ( $needle, array $haystack,  $strict = \fC\fBnull\fP\fP)"
Searches the array for a given value and returns the corresponding key if successful \fBmixed $needle \fP The searched value\&. 
.PP
If needle is a string, the comparison is done in a case-sensitive manner\&. 
.PP
\fBParameters\fP
.RS 4
\fI$haystack\fP 
.RE
.PP
The array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$strict\fP [optional] 
.RE
.PP
If the third parameter strict is set to true then the array_search function will also check the types of the needle in the haystack\&. 
.PP
\fBReturns\fP
.RS 4
int|string|false the key for needle if it is found in the array, false otherwise\&. 
.RE
.PP
.PP
If needle is found in haystack more than once, the first matching key is returned\&. To return the keys for all matching values, use array_keys with the optional search_value parameter instead\&. 
.PP
\fBSince\fP
.RS 4
4\&.0\&.5 
.PP
5\&.0 
.RE
.PP

.SS "array_shift (array & $array)"
Shift an element off the beginning of array \fBarray $array \fP The input array\&. 
.PP
\fBReturns\fP
.RS 4
mixed the shifted value, or  if array is empty or is not an array\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "array_slice (array $array,  $offset,  $length = \fC\fBnull\fP\fP,  $preserve_keys = \fC\fBfalse\fP\fP)"
Extract a slice of the array \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$offset\fP 
.RE
.PP
If offset is non-negative, the sequence will start at that offset in the array\&. If offset is negative, the sequence will start that far from the end of the array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$length\fP [optional] 
.RE
.PP
If length is given and is positive, then the sequence will have that many elements in it\&. If length is given and is negative then the sequence will stop that many elements from the end of the array\&. If it is omitted, then the sequence will have everything from offset up until the end of the array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$preserve_keys\fP [optional] 
.RE
.PP
Note that array_slice will reorder and reset the array indices by default\&. You can change this behaviour by setting preserve_keys to true\&. 
.PP
\fBReturns\fP
.RS 4
array the slice\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.PP
\fBExamples\fP
.in +1c
\fB/usr/local/var/www/safaricom\-sdp\-sdk/vendor/roave/better\-reflection/src/Reflection/ReflectionClass\&.php\fP\&.
.SS "array_splice (array & $input,  $offset,  $length = \fC\fBnull\fP\fP,  $replacement = \fC\fBnull\fP\fP)"
Remove a portion of the array and replace it with something else \fBarray $input \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$offset\fP 
.RE
.PP
If offset is positive then the start of removed portion is at that offset from the beginning of the input array\&. If offset is negative then it starts that far from the end of the input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$length\fP [optional] 
.RE
.PP
If length is omitted, removes everything from offset to the end of the array\&. If length is specified and is positive, then that many elements will be removed\&. If length is specified and is negative then the end of the removed portion will be that many elements from the end of the array\&. Tip: to remove everything from offset to the end of the array when replacement is also specified, use count($input) for length\&. 
.PP
\fBParameters\fP
.RS 4
\fI$replacement\fP [optional] 
.RE
.PP
If replacement array is specified, then the removed elements are replaced with elements from this array\&. 
.PP
If offset and length are such that nothing is removed, then the elements from the replacement array are inserted in the place specified by the offset\&. Note that keys in replacement array are not preserved\&. 
.PP
If replacement is just one element it is not necessary to put array() around it, unless the element is an array itself\&. 
.PP
\fBReturns\fP
.RS 4
array the array consisting of the extracted elements\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "array_unshift (array & $array,  $vars)"
Prepend elements to the beginning of an array Since 7\&.3\&.0 this function can be called with only one parameter\&. For earlier versions at least two parameters are required\&. \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$vars\fP [optional] 
.RE
.PP
The prepended variables\&. 
.PP
\fBReturns\fP
.RS 4
int the number of elements in the array\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "array_walk (array & $array,  $funcname,  $userdata = \fC\fBnull\fP\fP)"
Apply a user function to every member of an array \fBarray|ArrayObject $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$funcname\fP 
.RE
.PP
Typically, funcname takes on two parameters\&. The array parameter's value being the first, and the key/index second\&. 
.PP
If funcname needs to be working with the actual values of the array, specify the first parameter of funcname as a reference\&. Then, any changes made to those elements will be made in the original array itself\&. 
.PP
Users may not change the array itself from the callback function\&. e\&.g\&. Add/delete elements, unset elements, etc\&. If the array that array_walk is applied to is changed, the behavior of this function is undefined, and unpredictable\&. 
.PP
\fBParameters\fP
.RS 4
\fI$userdata\fP [optional] 
.RE
.PP
If the optional userdata parameter is supplied, it will be passed as the third parameter to the callback funcname\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "array_walk_recursive (array & $input,  $funcname,  $userdata = \fC\fBnull\fP\fP)"
Apply a user function recursively to every member of an array \fBarray|ArrayObject $input \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$funcname\fP 
.RE
.PP
Typically, funcname takes on two parameters\&. The input parameter's value being the first, and the key/index second\&. 
.PP
If funcname needs to be working with the actual values of the array, specify the first parameter of funcname as a reference\&. Then, any changes made to those elements will be made in the original array itself\&. 
.PP
\fBParameters\fP
.RS 4
\fI$userdata\fP [optional] 
.RE
.PP
If the optional userdata parameter is supplied, it will be passed as the third parameter to the callback funcname\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.0 
.RE
.PP

.SS "arsort (array & $array,  $sort_flags = \fC\fBnull\fP\fP)"
Sort an array in reverse order and maintain index association \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$sort_flags\fP [optional] 
.RE
.PP
You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "asort (array & $array,  $sort_flags = \fC\fBnull\fP\fP)"
Sort an array and maintain index association \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$sort_flags\fP [optional] 
.RE
.PP
You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "closelog ()"
Close connection to system logger \fBbool true on success or false on failure\&.  4\&.0  5\&.0 \fP
.SS "compact ( $varname,  $_ = \fC\fBnull\fP\fP)"
Create array containing variables and their values \fBmixed $varname \fP compact takes a variable number of parameters\&. Each parameter can be either a string containing the name of the variable, or an array of variable names\&. The array can contain other arrays of variable names inside it; compact handles it recursively\&. 
.PP
\fBParameters\fP
.RS 4
\fI$_\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
array the output array with all the variables added to it\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "count ( $var,  $mode = \fC\fBCOUNT_NORMAL\fP\fP)"
Counts all elements in an array, or something in an object\&. 
.PP
For objects, if you have SPL installed, you can hook into \fBcount()\fP by implementing interface {
.PP
\fBSee also\fP
.RS 4
\fBCountable\fP}\&. The interface has \fBexactly\fP one method, {
.PP
\fBCountable::count()\fP}, which returns the \fBreturn\fP value for the \fBcount()\fP \fBfunction\fP\&. Please see the {
.PP
Array} section of the manual for \fBa\fP detailed explanation of how arrays are implemented and used in PHP\&. \fBarray|Countable $var The array or the object\&.  int $mode [optional] If the optional mode parameter is set to COUNT_RECURSIVE (or 1), count will recursively count the array\&. This is particularly useful for counting all the elements of a multidimensional array\&. count does not detect infinite recursion\&.  int the number of elements in var, which is typically an array, since anything else will have one element\&. \fP 
.RE
.PP
If var is not an array or an object with implemented \fBCountable\fP interface, 1 will be returned\&. There is one exception, if var is , 0 will be returned\&. 
.PP
Caution: count may return 0 for a variable that isn't set, but it may also return 0 for a variable that has been initialized with an empty array\&. Use isset to test if a variable is set\&. 
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "current (array $array)"
Return the current element in an array \fBarray|object $array \fP The array\&. 
.PP
\fBReturns\fP
.RS 4
mixed The current function simply returns the value of the array element that's currently being pointed to by the internal pointer\&. It does not move the pointer in any way\&. If the internal pointer points beyond the end of the elements list or the array is empty, current returns false\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "define_syslog_variables ()"
Initializes all syslog related variables \fBdeprecated 276\&. void  4\&.0  5\&.0 \fP
.SS "end (array & $array)"
Set the internal pointer of an array to its last element \fBarray|object $array \fP The array\&. This array is passed by reference because it is modified by the function\&. This means you must pass it a real variable and not a function returning an array because only actual variables may be passed by reference\&. 
.PP
\fBReturns\fP
.RS 4
mixed the value of the last element or false for empty array\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "extract (array $var_array,  $extract_type = \fC\fBnull\fP\fP,  $prefix = \fC\fBnull\fP\fP)"
Import variables into the current symbol table from an array \fBarray $var_array\fP Note that prefix is only required if extract_type is EXTR_PREFIX_SAME, EXTR_PREFIX_ALL, EXTR_PREFIX_INVALID or EXTR_PREFIX_IF_EXISTS\&. If the prefixed result is not a valid variable name, it is not imported into the symbol table\&. Prefixes are automatically separated from the array key by an underscore character\&. 
.PP
\fBParameters\fP
.RS 4
\fI$extract_type\fP [optional] 
.RE
.PP
The way invalid/numeric keys and collisions are treated is determined by the extract_type\&. It can be one of the following values: EXTR_OVERWRITE If there is a collision, overwrite the existing variable\&. 
.PP
\fBParameters\fP
.RS 4
\fI$prefix\fP [optional] Only overwrite the variable if it already exists in the current symbol table, otherwise do nothing\&. This is useful for defining a list of valid variables and then extracting only those variables you have defined out of $_REQUEST, for example\&. 
.RE
.PP
\fBReturns\fP
.RS 4
int the number of variables successfully imported into the symbol table\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "getimagesizefromstring ( $imagedata, array & $imageinfo = \fC\fBnull\fP\fP)"
PHP > 5\&.4\&.0
.br
 Get the size of an image from a string\&. \fBstring $imagedata The image data, as a string\&.  array $imageinfo This optional parameter allows you to extract\fP some extended information from the image file\&. Currently, this will 
.br
 return the different JPG APP markers as an associative array\&. 
.br
 Some programs use these APP markers to embed text information in images\&. 
.br
 \fBA\fP very common one is to embed » IPTC information in the APP13 marker\&. 
.br
 You can use the \fBiptcparse()\fP function to parse the binary APP13 marker into something readable\&. 
.PP
\fBReturns\fP
.RS 4
array|false Returns an array with 7 elements\&.
.br
 Index 0 and 1 contains respectively the width and the height of the image\&.
.br
 Index 2 is one of the \fBIMAGETYPE_XXX\fP constants indicating the type of the image\&.
.br
 Index 3 is a text string with the correct \fBheight='yyy' width='xxx'\fP string
.br
 that can be used directly in an IMG tag\&.
.br
 On failure, FALSE is returned\&. 
.RE
.PP

.SS "header_register_callback (callable $callback)"
Registers a function that will be called when PHP starts sending output\&. The callback is executed just after PHP prepares all headers to be sent,
.br
 and before any other output is sent, creating a window to manipulate the outgoing headers before being sent\&. @linkhttps://secure\&.php\&.net/manual/en/function\&.header-register-callback\&.php 
.PP
\fBParameters\fP
.RS 4
\fI$callback\fP Function called just before the headers are sent\&. 
.RE
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "in_array ( $needle, array $haystack,  $strict = \fC\fBfalse\fP\fP)"
Checks if a value exists in an array \fBmixed $needle \fP The searched value\&. 
.PP
If needle is a string, the comparison is done in a case-sensitive manner\&. 
.PP
\fBParameters\fP
.RS 4
\fI$haystack\fP 
.RE
.PP
The array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$strict\fP [optional] 
.RE
.PP
If the third parameter strict is set to true then the in_array function will also check the types of the needle in the haystack\&. 
.PP
\fBReturns\fP
.RS 4
bool true if needle is found in the array, false otherwise\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.PP
\fBExamples\fP
.in +1c
\fB/usr/local/var/www/safaricom\-sdp\-sdk/vendor/roave/better\-reflection/src/Reflection/ReflectionClass\&.php\fP\&.
.SS "key (array $array)"
Fetch a key from an array \fBarray|object $array \fP The array\&. 
.PP
\fBReturns\fP
.RS 4
int|string|null The key function simply returns the key of the array element that's currently being pointed to by the internal pointer\&. It does not move the pointer in any way\&. If the internal pointer points beyond the end of the elements list or the array is empty, key returns \&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "krsort (array & $array,  $sort_flags = \fC\fBnull\fP\fP)"
Sort an array by key in reverse order \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$sort_flags\fP [optional] 
.RE
.PP
You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "ksort (array & $array,  $sort_flags = \fC\fBnull\fP\fP)"
Sort an array by key \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$sort_flags\fP [optional] 
.RE
.PP
You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "lcg_value ()"
Combined linear congruential generator \fBfloat A pseudo random float value in the range of (0, 1)  4\&.0  5\&.0 \fP
.SS "max ( $value1,  $value2 = \fC\fBnull\fP\fP,  $values)"
Find highest value \fBarray|mixed $value1 Array to look through or first value to compare  mixed $value2 [optional] second value to compare \fP 
.PP
\fBParameters\fP
.RS 4
\fI$values\fP [optional] any comparable value 
.RE
.PP
\fBReturns\fP
.RS 4
mixed max returns the numerically highest of the parameter values, either within a arg array or two arguments\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "metaphone ( $str,  $phonemes = \fC0\fP)"
Calculate the metaphone key of a string \fBstring $str \fP The input string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$phonemes\fP [optional] 
.RE
.PP
This parameter restricts the returned metaphone key to phonemes characters in length\&. The default value of 0 means no restriction\&. 
.PP
\fBReturns\fP
.RS 4
string|false the metaphone key as a string, or FALSE on failure 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "min ( $value1,  $value2 = \fC\fBnull\fP\fP,  $values)"
Find lowest value \fBarray|mixed $value1 Array to look through or first value to compare  mixed $value2 [optional] second value to compare \fP 
.PP
\fBParameters\fP
.RS 4
\fI$values\fP [optional] any comparable value 
.RE
.PP
\fBReturns\fP
.RS 4
mixed min returns the numerically lowest of the parameter values\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "natcasesort (array & $array)"
Sort an array using a case insensitive 'natural order' algorithm \fBarray $array \fP The input array\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "natsort (array & $array)"
Sort an array using a 'natural order' algorithm \fBarray $array \fP The input array\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "next (array & $array)"
Advance the internal array pointer of an array \fBarray|object $array \fP The array being affected\&. 
.PP
\fBReturns\fP
.RS 4
mixed the array value in the next place that's pointed to by the internal array pointer, or false if there are no more elements\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "ob_clean ()"
Clean (erase) the output buffer \fBvoid  4\&.2  5\&.0 \fP
.SS "ob_end_clean ()"
Clean (erase) the output buffer and turn off output buffering \fBbool true on success or false on failure\&. Reasons for failure are first that you called the function without an active buffer or that for some reason a buffer could not be deleted (possible for special buffer)\&.  4\&.0  5\&.0 \fP
.SS "ob_end_flush ()"
Flush (send) the output buffer and turn off output buffering \fBbool true on success or false on failure\&. Reasons for failure are first that you called the function without an active buffer or that for some reason a buffer could not be deleted (possible for special buffer)\&.  4\&.0  5\&.0 \fP
.SS "ob_flush ()"
Flush (send) the output buffer \fBvoid  4\&.2  5\&.0 \fP
.SS "ob_get_clean ()"
Get current buffer contents and delete current output buffer \fBstring|false the contents of the output buffer and end output buffering\&. If output buffering isn't active then false is returned\&.  4\&.3  5\&.0 \fP
.SS "ob_get_contents ()"
Return the contents of the output buffer \fBstring|false This will return the contents of the output buffer or false, if output buffering isn't active\&.  4\&.0  5\&.0 \fP
.SS "ob_get_flush ()"
Flush the output buffer, return it as a string and turn off output buffering \fBstring|false the output buffer or false if no buffering is active\&.  4\&.3  5\&.0 \fP
.SS "ob_get_length ()"
Return the length of the output buffer \fBint|false the length of the output buffer contents or false if no buffering is active\&.  4\&.0\&.2  5\&.0 \fP
.SS "ob_get_level ()"
Return the nesting level of the output buffering mechanism \fBint the level of nested output buffering handlers or zero if output buffering is not active\&.  4\&.2  5\&.0 \fP
.SS "ob_get_status ( $full_status = \fC\fBnull\fP\fP)"
Get status of output buffers \fBbool $full_status [optional] \fP true to return all active output buffer levels\&. If false or not set, only the top level output buffer is returned\&. 
.PP
\fBReturns\fP
.RS 4
array If called without the full_status parameter or with full_status = false a simple array with the following elements is returned: 
.PP
.nf

Array 
(
    [level] => 2
    [type] => 0
    [status] => 0
    [name] => URL-Rewriter
    [del] => 1 
)
.fi
.PP
 KeyValue levelOutput nesting level type\fIPHP_OUTPUT_HANDLER_INTERNAL (0)\fP or \fIPHP_OUTPUT_HANDLER_USER (1)\fP statusOne of \fIPHP_OUTPUT_HANDLER_START\fP (0), \fIPHP_OUTPUT_HANDLER_CONT\fP (1) or \fIPHP_OUTPUT_HANDLER_END\fP (2) nameName of active output handler or &#039; default output handler&#039; if none is set delErase-flag as set by \fBob_start()\fP 
.RE
.PP
If called with full_status = TRUE an array with one element for each active output buffer level is returned\&. The output level is used as key of the top level array and each array element itself is another array holding status information on one active output level\&. 
.PP
.PP
.nf

Array
(
    [0] => Array
        (
            [chunk_size] => 0
            [size] => 40960
            [block_size] => 10240
            [type] => 1
            [status] => 0
            [name] => default output handler
            [del] => 1
        )
.fi
.PP
.PP
.PP
.nf
    [1] => Array
        (
            [chunk_size] => 0
            [size] => 40960
            [block_size] => 10240
            [type] => 0
            [buffer_size] => 0
            [status] => 0
            [name] => URL-Rewriter
            [del] => 1
        )
.fi
.PP
.PP
.PP
.nf
)
.fi
.PP
 <p<blockquote> The full output contains these additional elements:
.PP
KeyValue chunk_sizeChunk size as set by \fBob_start()\fP size\&.\&.\&. blocksize\&.\&.\&. 
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "ob_implicit_flush ( $flag = \fC1\fP)"
Turn implicit flush on/off \fBint $flag [optional] \fP 1 to turn implicit flushing on, 0 otherwise\&. 
.PP
\fBReturns\fP
.RS 4
void 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "ob_list_handlers ()"
List all output handlers in use \fBarray This will return an array with the output handlers in use (if any)\&. If output_buffering is enabled or an anonymous function was used with ob_start, ob_list_handlers will return 'default output
handler'\&.  4\&.3  5\&.0 \fP
.SS "ob_start ( $output_callback = \fC\fBnull\fP\fP,  $chunk_size = \fC\fBnull\fP\fP,  $erase = \fC\fBnull\fP\fP)"
Turn on output buffering \fBcallback $output_callback [optional] \fP An optional output_callback function may be specified\&. This function takes a string as a parameter and should return a string\&. The function will be called when the output buffer is flushed (sent) or cleaned (with ob_flush, ob_clean or similar function) or when the output buffer is flushed to the browser at the end of the request\&. When output_callback is called, it will receive the contents of the output buffer as its parameter and is expected to return a new output buffer as a result, which will be sent to the browser\&. If the output_callback is not a callable function, this function will return false\&. 
.PP
If the callback function has two parameters, the second parameter is filled with a bit-field consisting of PHP_OUTPUT_HANDLER_START, PHP_OUTPUT_HANDLER_CONT and PHP_OUTPUT_HANDLER_END\&. 
.PP
If output_callback returns false original input is sent to the browser\&. 
.PP
The output_callback parameter may be bypassed by passing a  value\&. 
.PP
ob_end_clean, ob_end_flush, ob_clean, ob_flush and ob_start may not be called from a callback function\&. If you call them from callback function, the behavior is undefined\&. If you would like to delete the contents of a buffer, return '' (a null string) from callback function\&. You can't even call functions using the output buffering functions like print_r($expression, true) or highlight_file($filename, true) from a callback function\&. 
.PP
In PHP 4\&.0\&.4, ob_gzhandler was introduced to facilitate sending gz-encoded data to web browsers that support compressed web pages\&. ob_gzhandler determines what type of content encoding the browser will accept and will return its output accordingly\&. 
.PP
\fBParameters\fP
.RS 4
\fI$chunk_size\fP [optional] 
.RE
.PP
If the optional parameter chunk_size is passed, the buffer will be flushed after any output call which causes the buffer's length to equal or exceed chunk_size\&. Default value 0 means that the function is called only in the end, other special value 1 sets chunk_size to 4096\&. 
.PP
\fBParameters\fP
.RS 4
\fI$erase\fP [optional] 
.RE
.PP
If the optional parameter erase is set to false, the buffer will not be deleted until the script finishes\&. This causes that flushing and cleaning functions would issue a notice and return false if called\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "prev (array & $array)"
Rewind the internal array pointer \fBarray|object $array \fP The input array\&. 
.PP
\fBReturns\fP
.RS 4
mixed the array value in the previous place that's pointed to by the internal array pointer, or false if there are no more elements\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "range ( $start,  $end,  $step = \fC1\fP)"
Create an array containing a range of elements \fBmixed $start \fP First value of the sequence\&. 
.PP
\fBParameters\fP
.RS 4
\fI$end\fP 
.RE
.PP
The sequence is ended upon reaching the end value\&. 
.PP
\fBParameters\fP
.RS 4
\fI$step\fP [optional] 
.RE
.PP
If a step value is given, it will be used as the increment between elements in the sequence\&. step should be given as a positive number\&. If not specified, step will default to 1\&. 
.PP
\fBReturns\fP
.RS 4
array an array of elements from start to end, inclusive\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "reset (array & $array)"
Set the internal pointer of an array to its first element \fBarray|object $array \fP The input array\&. 
.PP
\fBReturns\fP
.RS 4
mixed the value of the first array element, or false if the array is empty\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "rsort (array & $array,  $sort_flags = \fC\fBnull\fP\fP)"
Sort an array in reverse order \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$sort_flags\fP [optional] 
.RE
.PP
You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "shuffle (array & $array)"
Shuffle an array \fBarray $array \fP The array\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "sort (array & $array,  $sort_flags = \fC\fBnull\fP\fP)"
Sort an array \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$sort_flags\fP [optional] 
.RE
.PP
The optional second parameter sort_flags may be used to modify the sorting behavior using these values: 
.PP
Sorting type flags: SORT_REGULAR - compare items normally (don't change types) 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.PP
\fBExamples\fP
.in +1c
\fB/usr/local/var/www/safaricom\-sdp\-sdk/vendor/jetbrains/phpstorm\-stubs/redis/Redis\&.php\fP\&.
.SS "stream_set_chunk_size ( $fp,  $chunk_size)"
PHP > 5\&.4\&.0
.br
 Set the stream chunk size\&. \fBresource $fp The target stream\&.  int $chunk_size The desired new chunk size\&.  int|false Returns the previous chunk size on success\&.\fP Will return \fBFALSE\fP if chunk_size is less than 1 or greater than \fBPHP_INT_MAX\fP\&. 
.SS "syslog ( $priority,  $message)"
Generate a system log message \fBint $priority \fP priority is a combination of the facility and the level\&. Possible values are: Priorities (in descending order) 
.PP
Constant 
.PP
Description  
.PP
LOG_EMERG 
.PP
system is unusable  
.PP
LOG_ALERT 
.PP
action must be taken immediately  
.PP
LOG_CRIT 
.PP
critical conditions  
.PP
LOG_ERR 
.PP
error conditions  
.PP
LOG_WARNING 
.PP
warning conditions  
.PP
LOG_NOTICE 
.PP
normal, but significant, condition  
.PP
LOG_INFO 
.PP
informational message  
.PP
LOG_DEBUG 
.PP
debug-level message  
.PP
\fBParameters\fP
.RS 4
\fI$message\fP 
.RE
.PP
The message to send, except that the two characters m will be replaced by the error message string (strerror) corresponding to the present value of errno\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "uasort (array & $array,  $cmp_function)"
Sort an array with a user-defined comparison function and maintain index association \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$cmp_function\fP 
.RE
.PP
See usort and uksort for examples of user-defined comparison functions\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "uksort (array & $array,  $cmp_function)"
Sort an array by keys using a user-defined comparison function \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$cmp_function\fP 
.RE
.PP
The callback comparison function\&. 
.PP
Function cmp_function should accept two parameters which will be filled by pairs of array keys\&. The comparison function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SS "usort (array & $array,  $cmp_function)"
Sort an array by values using a user-defined comparison function \fBarray $array \fP The input array\&. 
.PP
\fBParameters\fP
.RS 4
\fI$cmp_function\fP 
.RE
.PP
The comparison function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0 
.PP
5\&.0 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Safaricom SDP from the source code\&.
