{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/usr/local/var/www/safaricom-sdp-sdk/vendor/roave/better-reflection/src/Reflection/ReflectionClass.php\par \pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a list of the aliases used when importing traits for this class. The returned array is in key/value pair in this format:.\par
'aliasedMethodName' => 'ActualClass::actualMethod'\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
array<string, string>\par
}}// When reflecting a class such as: class {\b Foo} \{ use MyTrait \{ myTraitMethod as myAliasedMethod; \} \} // This method would return // ['myAliasedMethod' => 'MyTrait::myTraitMethod']\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid <?php\par
\par
declare(strict_types=1);\par
\par
{\cf17 namespace }Roave\\BetterReflection\\Reflection;\par
\par
use OutOfBoundsException;\par
use PhpParser\\Node;\par
use PhpParser\\Node\\Stmt\\Class_ as ClassNode;\par
use PhpParser\\Node\\Stmt\\ClassConst as ConstNode;\par
use PhpParser\\Node\\Stmt\\ClassLike as ClassLikeNode;\par
use PhpParser\\Node\\Stmt\\ClassMethod;\par
use PhpParser\\Node\\Stmt\\Interface_ as InterfaceNode;\par
use PhpParser\\Node\\Stmt\\Namespace_ as NamespaceNode;\par
use PhpParser\\Node\\Stmt\\Namespace_;\par
use PhpParser\\Node\\Stmt\\Property as PropertyNode;\par
use PhpParser\\Node\\Stmt\\Trait_ as TraitNode;\par
use PhpParser\\Node\\Stmt\\TraitUse;\par
use ReflectionClass as CoreReflectionClass;\par
use ReflectionException;\par
use ReflectionProperty as CoreReflectionProperty;\par
use Roave\\BetterReflection\\BetterReflection;\par
use Roave\\BetterReflection\\Reflection\\Exception\\ClassDoesNotExist;\par
use Roave\\BetterReflection\\Reflection\\Exception\\NoObjectProvided;\par
use Roave\\BetterReflection\\Reflection\\Exception\\NotAClassReflection;\par
use Roave\\BetterReflection\\Reflection\\Exception\\NotAnInterfaceReflection;\par
use Roave\\BetterReflection\\Reflection\\Exception\\NotAnObject;\par
use Roave\\BetterReflection\\Reflection\\Exception\\ObjectNotInstanceOfClass;\par
use Roave\\BetterReflection\\Reflection\\Exception\\PropertyDoesNotExist;\par
use Roave\\BetterReflection\\Reflection\\Exception\\Uncloneable;\par
use Roave\\BetterReflection\\Reflection\\StringCast\\ReflectionClassStringCast;\par
use Roave\\BetterReflection\\Reflector\\Exception\\IdentifierNotFound;\par
use Roave\\BetterReflection\\Reflector\\Reflector;\par
use Roave\\BetterReflection\\SourceLocator\\Located\\LocatedSource;\par
use Roave\\BetterReflection\\Util\\CalculateReflectionColumn;\par
use Roave\\BetterReflection\\Util\\GetLastDocComment;\par
use Traversable;\par
\par
use {\cf17 function} array_combine;\par
use {\cf17 function} array_filter;\par
use {\cf17 function} array_key_exists;\par
use {\cf17 function} array_map;\par
use {\cf17 function} array_merge;\par
use {\cf17 function} array_reverse;\par
use {\cf17 function} array_slice;\par
use {\cf17 function} array_values;\par
use {\cf17 function} assert;\par
use {\cf17 function} implode;\par
use {\cf17 function} in_array;\par
use {\cf17 function} ltrim;\par
use {\cf17 function} sha1;\par
use {\cf17 function} sprintf;\par
use {\cf17 function} strtolower;\par
\par
{\cf17 class }ReflectionClass {\cf17 implements} Reflection\par
\{\par
    {\cf17 public} {\cf17 const} ANONYMOUS_CLASS_NAME_PREFIX = {\cf22 'class@anonymous'};\par
\par
    {\cf17 private} Reflector $reflector;\par
\par
    {\cf17 private} ?NamespaceNode $declaringNamespace = {\cf17 null};\par
\par
    {\cf17 private} LocatedSource $locatedSource;\par
\par
    {\cf17 private} ClassLikeNode $node;\par
\par
    {\cf17 private} ?array $cachedReflectionConstants = {\cf17 null};\par
\par
    {\cf17 private} ?array $cachedImmediateProperties = {\cf17 null};\par
\par
    {\cf17 private} ?array $cachedProperties = {\cf17 null};\par
\par
    {\cf17 private} ?array $cachedMethods = {\cf17 null};\par
\par
    {\cf17 private} ?array $cachedTraitAliases = {\cf17 null};\par
\par
    {\cf17 private} ?array $cachedTraitPrecedences = {\cf17 null};\par
\par
    {\cf17 private} ?ReflectionClass $cachedParentClass = {\cf17 null};\par
\par
    {\cf17 private} {\cf17 function} __construct()\par
    \{\par
    \}\par
\par
    {\cf17 public} {\cf17 function} __toString(): string\par
    \{\par
        {\cf19 return} ReflectionClassStringCast::toString($this);\par
    \}\par
\par
    {\cf17 public} {\cf17 static} {\cf17 function} createFromName({\cf18 string} $className): self\par
    \{\par
        {\cf19 return} ({\cf17 new} BetterReflection())->classReflector()->reflect($className);\par
    \}\par
\par
    {\cf17 public} {\cf17 static} {\cf17 function} createFromInstance({\cf18 object} $instance): self\par
    \{\par
        {\cf19 return} ReflectionObject::createFromInstance($instance);\par
    \}\par
\par
    {\cf17 public} {\cf17 static} {\cf17 function} createFromNode(\par
        Reflector $reflector,\par
        ClassLikeNode $node,\par
        LocatedSource $locatedSource,\par
        ?NamespaceNode $namespace = {\cf17 null}\par
    ): self \{\par
        $class = {\cf17 new} {\cf17 self}();\par
\par
        $class->reflector          = $reflector;\par
        $class->locatedSource      = $locatedSource;\par
        $class->node               = $node;\par
        $class->declaringNamespace = $namespace;\par
\par
        {\cf19 return} $class;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getShortName(): string\par
    \{\par
        {\cf19 if} (! $this->isAnonymous()) \{\par
            assert($this->node->name instanceof Node\\Identifier);\par
\par
            {\cf19 return} $this->node->name->name;\par
        \}\par
\par
        $fileName = $this->getFileName();\par
\par
        {\cf19 if} ($fileName === {\cf17 null}) \{\par
            $fileName = sha1($this->locatedSource->getSource());\par
        \}\par
\par
        {\cf19 return} sprintf({\cf22 '%s%c%s(%d)'}, self::ANONYMOUS_CLASS_NAME_PREFIX, {\cf22 "\\0"}, $fileName, $this->getStartLine());\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getName(): string\par
    \{\par
        {\cf19 if} (! $this->inNamespace()) \{\par
            {\cf19 return} $this->getShortName();\par
        \}\par
\par
        {\cf19 return} $this->node->namespacedName->toString();\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getNamespaceName(): string\par
    \{\par
        {\cf19 if} (! $this->inNamespace()) \{\par
            {\cf19 return} {\cf22 ''};\par
        \}\par
\par
        {\cf19 return} implode({\cf23 '\\\\'}, $this->declaringNamespace->name->parts);\par
    \}\par
\par
    {\cf17 public} {\cf17 function} inNamespace(): bool\par
    \{\par
        {\cf19 return} $this->declaringNamespace !== {\cf17 null}\par
            && $this->declaringNamespace->name !== {\cf17 null};\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getExtensionName(): ?string\par
    \{\par
        {\cf19 return} $this->locatedSource->getExtensionName();\par
    \}\par
\par
    {\cf17 private} {\cf17 function} createMethodsFromTrait(ReflectionMethod $method): array\par
    \{\par
        $traitAliases     = $this->getTraitAliases();\par
        $traitPrecedences = $this->getTraitPrecedences();\par
\par
        $methodAst = $method->getAst();\par
        assert($methodAst instanceof ClassMethod);\par
\par
        $methodHash   = $this->methodHash($method->getImplementingClass()->getName(), $method->getName());\par
        $createMethod = {\cf17 function} (?{\cf18 string} $aliasMethodName) use ($method, $methodAst): ReflectionMethod \{\par
            {\cf19 return} ReflectionMethod::createFromNode(\par
                $this->reflector,\par
                $methodAst,\par
                $method->getDeclaringClass()->getDeclaringNamespaceAst(),\par
                $method->getDeclaringClass(),\par
                $this,\par
                $aliasMethodName,\par
            );\par
        \};\par
\par
        $methods = [];\par
        {\cf19 foreach} ($traitAliases as $aliasMethodName => $traitAliasDefinition) \{\par
            {\cf19 if} ($methodHash !== $traitAliasDefinition) \{\par
                {\cf19 continue};\par
            \}\par
\par
            $methods[] = $createMethod($aliasMethodName);\par
        \}\par
\par
        {\cf19 if} (! array_key_exists($methodHash, $traitPrecedences)) \{\par
            $methods[] = $createMethod($method->getAliasName());\par
        \}\par
\par
        {\cf19 return} $methods;\par
    \}\par
\par
    {\cf17 private} {\cf17 function} getParentMethods(): array\par
    \{\par
        {\cf19 return} array_merge(\par
            [],\par
            ...array_map(\par
                {\cf17 static} {\cf17 function} (ReflectionClass $ancestor): array \{\par
                    {\cf19 return} $ancestor->getMethods();\par
                \},\par
                array_filter([$this->getParentClass()]),\par
            ),\par
        );\par
    \}\par
\par
    {\cf17 private} {\cf17 function} getMethodsFromTraits(): array\par
    \{\par
        {\cf19 return} array_merge(\par
            [],\par
            ...array_map(\par
                {\cf17 function} (ReflectionClass $trait): array \{\par
                    {\cf19 return} array_merge(\par
                        [],\par
                        ...array_map(\par
                            {\cf17 function} (ReflectionMethod $method): array \{\par
                                {\cf19 return} $this->createMethodsFromTrait($method);\par
                            \},\par
                            $trait->getMethods(),\par
                        ),\par
                    );\par
                \},\par
                $this->getTraits(),\par
            ),\par
        );\par
    \}\par
\par
    {\cf17 private} {\cf17 function} getMethodsFromInterfaces(): array\par
    \{\par
        {\cf19 return} array_merge(\par
            [],\par
            ...array_map(\par
                {\cf17 static} {\cf17 function} (ReflectionClass $ancestor): array \{\par
                    {\cf19 return} $ancestor->getMethods();\par
                \},\par
                array_values($this->getInterfaces()),\par
            ),\par
        );\par
    \}\par
\par
    {\cf17 private} {\cf17 function} getMethodsIndexedByName(): array\par
    \{\par
        {\cf19 if} ($this->cachedMethods !== {\cf17 null}) \{\par
            {\cf19 return} $this->cachedMethods;\par
        \}\par
\par
        $classMethods     = $this->getImmediateMethods();\par
        $parentClass      = $this->getParentClass();\par
        $parentClassName  = $parentClass !== {\cf17 null} ? $parentClass->getName() : {\cf17 null};\par
        $parentMethods    = $this->getParentMethods();\par
        $traitsMethods    = $this->getMethodsFromTraits();\par
        $interfaceMethods = $this->getMethodsFromInterfaces();\par
\par
        $methods = [];\par
\par
        {\cf19 foreach} ([$classMethods, $parentMethods, {\cf22 'traits'} => $traitsMethods, $interfaceMethods] as $type => $typeMethods) \{\par
            {\cf19 foreach} ($typeMethods as $method) \{\par
                $methodName = strtolower($method->getName());\par
\par
                {\cf19 if} (! array_key_exists($methodName, $methods)) \{\par
                    $methods[$methodName] = $method;\par
                    {\cf19 continue};\par
                \}\par
\par
                {\cf19 if} ($type !== {\cf22 'traits'}) \{\par
                    {\cf19 continue};\par
                \}\par
\par
                $existingMethod = $methods[$methodName];\par
\par
                {\cf20 // Non-abstract trait method can overwrite existing methods:}\par
                {\cf20 // - when existing method comes from parent class}\par
                {\cf20 // - when existing method comes from trait and is abstract}\par
                {\cf19 if} (\par
                    ! (\par
                    ! $method->isAbstract()\par
                    && (\par
                        $existingMethod->getDeclaringClass()->getName() === $parentClassName\par
                        || (\par
                            $existingMethod->isAbstract()\par
                            && $existingMethod->getDeclaringClass()->isTrait()\par
                        )\par
                    )\par
                    )\par
                ) \{\par
                    {\cf19 continue};\par
                \}\par
\par
                $methods[$methodName] = $method;\par
            \}\par
        \}\par
\par
        $this->cachedMethods = $methods;\par
\par
        {\cf19 return} $this->cachedMethods;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getMethods(?{\cf18 int} $filter = {\cf17 null}): array\par
    \{\par
        {\cf19 if} ($filter === {\cf17 null}) \{\par
            {\cf19 return} array_values($this->getMethodsIndexedByName());\par
        \}\par
\par
        {\cf19 return} array_values(\par
            array_filter(\par
                $this->getMethodsIndexedByName(),\par
                {\cf17 static} {\cf17 function} (ReflectionMethod $method) use ($filter): {\cf18 bool} \{\par
                    {\cf19 return} ({\cf18 bool}) ($filter & $method->getModifiers());\par
                \},\par
            ),\par
        );\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getImmediateMethods(?{\cf18 int} $filter = {\cf17 null}): array\par
    \{\par
        $methods = array_map(\par
            {\cf17 function} (ClassMethod $methodNode): ReflectionMethod \{\par
                {\cf19 return} ReflectionMethod::createFromNode(\par
                    $this->reflector,\par
                    $methodNode,\par
                    $this->declaringNamespace,\par
                    $this,\par
                    $this,\par
                );\par
            \},\par
            $this->node->getMethods(),\par
        );\par
\par
        $methodsByName = [];\par
\par
        {\cf19 foreach} ($methods as $method) \{\par
            {\cf19 if} ($filter !== {\cf17 null} && ! ($filter & $method->getModifiers())) \{\par
                {\cf19 continue};\par
            \}\par
\par
            $methodsByName[$method->getName()] = $method;\par
        \}\par
\par
        {\cf19 return} $methodsByName;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getMethod({\cf18 string} $methodName): ReflectionMethod\par
    \{\par
        $lowercaseMethodName = strtolower($methodName);\par
        $methods             = $this->getMethodsIndexedByName();\par
\par
        {\cf19 if} (! isset($methods[$lowercaseMethodName])) \{\par
            {\cf19 throw} {\cf17 new} OutOfBoundsException({\cf22 'Could not find method: '} . $methodName);\par
        \}\par
\par
        {\cf19 return} $methods[$lowercaseMethodName];\par
    \}\par
\par
    {\cf17 public} {\cf17 function} hasMethod({\cf18 string} $methodName): bool\par
    \{\par
        {\cf19 try} \{\par
            $this->getMethod($methodName);\par
\par
            {\cf19 return} {\cf17 true};\par
        \} {\cf19 catch} (OutOfBoundsException $exception) \{\par
            {\cf19 return} {\cf17 false};\par
        \}\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getImmediateConstants(): array\par
    \{\par
        {\cf19 return} array_map({\cf17 static} {\cf17 function} (ReflectionClassConstant $classConstant) \{\par
            {\cf19 return} $classConstant->getValue();\par
        \}, $this->getImmediateReflectionConstants());\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getConstants(): array\par
    \{\par
        {\cf19 return} array_map({\cf17 static} {\cf17 function} (ReflectionClassConstant $classConstant) \{\par
            {\cf19 return} $classConstant->getValue();\par
        \}, $this->getReflectionConstants());\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getConstant({\cf18 string} $name)\par
    \{\par
        $reflectionConstant = $this->getReflectionConstant($name);\par
\par
        {\cf19 if} (! $reflectionConstant) \{\par
            {\cf19 return} {\cf17 null};\par
        \}\par
\par
        {\cf19 return} $reflectionConstant->getValue();\par
    \}\par
\par
    {\cf17 public} {\cf17 function} hasConstant({\cf18 string} $name): bool\par
    \{\par
        {\cf19 return} $this->getReflectionConstant($name) !== {\cf17 null};\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getReflectionConstant({\cf18 string} $name): ?ReflectionClassConstant\par
    \{\par
        {\cf19 return} $this->getReflectionConstants()[$name] ?? {\cf17 null};\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getImmediateReflectionConstants(): array\par
    \{\par
        {\cf19 if} ($this->cachedReflectionConstants !== {\cf17 null}) \{\par
            {\cf19 return} $this->cachedReflectionConstants;\par
        \}\par
\par
        $constants = array_merge(\par
            [],\par
            ...array_map(\par
                {\cf17 function} (ConstNode $constNode): array \{\par
                    $constants = [];\par
\par
                    {\cf19 foreach} ($constNode->consts as $constantPositionInNode => $constantNode) \{\par
                        $constants[] = ReflectionClassConstant::createFromNode($this->reflector, $constNode, $constantPositionInNode, $this);\par
                    \}\par
\par
                    {\cf19 return} $constants;\par
                \},\par
                array_filter(\par
                    $this->node->stmts,\par
                    {\cf17 static} function (Node\\Stmt $stmt): {\cf18 bool} \{\par
                        {\cf19 return} $stmt instanceof ConstNode;\par
                    \},\par
                ),\par
            ),\par
        );\par
\par
        {\cf19 return} $this->cachedReflectionConstants = array_combine(\par
            array_map(\par
                {\cf17 static} {\cf17 function} (ReflectionClassConstant $constant): {\cf18 string} \{\par
                    {\cf19 return} $constant->getName();\par
                \},\par
                $constants,\par
            ),\par
            $constants,\par
        );\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getReflectionConstants(): array\par
    \{\par
        {\cf20 // Note: constants are not merged via their name as array index, since internal PHP constant}\par
        {\cf20 //       sorting does not follow `\\array_merge()` semantics}\par
{\cf20 }        $allReflectionConstants = array_merge(\par
            array_values($this->getImmediateReflectionConstants()),\par
            ...array_map(\par
                {\cf17 static} {\cf17 function} (ReflectionClass $ancestor): array \{\par
                    {\cf19 return} array_filter(\par
                        array_values($ancestor->getReflectionConstants()),\par
                        {\cf17 static} function (ReflectionClassConstant $classConstant): {\cf18 bool} \{\par
                            {\cf19 return} ! $classConstant->isPrivate();\par
                        \},\par
                    );\par
                \},\par
                array_filter([$this->getParentClass()]),\par
            ),\par
            ...array_map(\par
                {\cf17 static} {\cf17 function} (ReflectionClass $interface): array \{\par
                    {\cf19 return} array_values($interface->getReflectionConstants());\par
                \},\par
                array_values($this->getInterfaces()),\par
            ),\par
        );\par
\par
        $reflectionConstants = [];\par
\par
        {\cf19 foreach} ($allReflectionConstants as $constant) \{\par
            $constantName = $constant->getName();\par
\par
            {\cf19 if} (isset($reflectionConstants[$constantName])) \{\par
                {\cf19 continue};\par
            \}\par
\par
            $reflectionConstants[$constantName] = $constant;\par
        \}\par
\par
        {\cf19 return} $reflectionConstants;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getConstructor(): ReflectionMethod\par
    \{\par
        $constructors = array_values(array_filter($this->getMethods(), {\cf17 static} {\cf17 function} (ReflectionMethod $method): {\cf18 bool} \{\par
            {\cf19 return} $method->isConstructor();\par
        \}));\par
\par
        {\cf19 if} (! isset($constructors[0])) \{\par
            {\cf19 throw} {\cf17 new} OutOfBoundsException({\cf22 'Could not find method: __construct'});\par
        \}\par
\par
        {\cf19 return} $constructors[0];\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getImmediateProperties(?{\cf18 int} $filter = {\cf17 null}): array\par
    \{\par
        {\cf19 if} ($this->cachedImmediateProperties === {\cf17 null}) \{\par
            $properties = [];\par
            {\cf19 foreach} ($this->node->stmts as $stmt) \{\par
                {\cf19 if} (! ($stmt instanceof PropertyNode)) \{\par
                    {\cf19 continue};\par
                \}\par
\par
                {\cf19 foreach} ($stmt->props as $propertyPositionInNode => $propertyNode) \{\par
                    $prop                         = ReflectionProperty::createFromNode(\par
                        $this->reflector,\par
                        $stmt,\par
                        $propertyPositionInNode,\par
                        $this->declaringNamespace,\par
                        $this,\par
                        $this,\par
                    );\par
                    $properties[$prop->getName()] = $prop;\par
                \}\par
            \}\par
\par
            $this->cachedImmediateProperties = $properties;\par
        \}\par
\par
        {\cf19 if} ($filter === {\cf17 null}) \{\par
            {\cf19 return} $this->cachedImmediateProperties;\par
        \}\par
\par
        {\cf19 return} array_filter(\par
            $this->cachedImmediateProperties,\par
            {\cf17 static} {\cf17 function} (ReflectionProperty $property) use ($filter): {\cf18 bool} \{\par
                {\cf19 return} ({\cf18 bool}) ($filter & $property->getModifiers());\par
            \},\par
        );\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getProperties(?{\cf18 int} $filter = {\cf17 null}): array\par
    \{\par
        {\cf19 if} ($this->cachedProperties === {\cf17 null}) \{\par
            {\cf20 // merging together properties from parent class, traits, current class (in this precise order)}\par
            $this->cachedProperties = array_merge(\par
                array_merge(\par
                    [],\par
                    ...array_map(\par
                        {\cf17 static} {\cf17 function} (ReflectionClass $ancestor) use ($filter): array \{\par
                            {\cf19 return} array_filter(\par
                                $ancestor->getProperties($filter),\par
                                {\cf17 static} function (ReflectionProperty $property): {\cf18 bool} \{\par
                                    {\cf19 return} ! $property->isPrivate();\par
                                \},\par
                            );\par
                        \},\par
                        array_filter([$this->getParentClass()]),\par
                    ),\par
                    ...array_map(\par
                        {\cf17 function} (ReflectionClass $trait) use ($filter) \{\par
                            {\cf19 return} array_map({\cf17 function} (ReflectionProperty $property) use ($trait): ReflectionProperty \{\par
                                {\cf19 return} ReflectionProperty::createFromNode(\par
                                    $this->reflector,\par
                                    $property->getAst(),\par
                                    $property->getPositionInAst(),\par
                                    $trait->declaringNamespace,\par
                                    $property->getDeclaringClass(),\par
                                    $this,\par
                                );\par
                            \}, $trait->getProperties($filter));\par
                        \},\par
                        $this->getTraits(),\par
                    ),\par
                ),\par
                $this->getImmediateProperties(),\par
            );\par
        \}\par
\par
        {\cf19 if} ($filter === {\cf17 null}) \{\par
            {\cf19 return} $this->cachedProperties;\par
        \}\par
\par
        {\cf19 return} array_filter(\par
            $this->cachedProperties,\par
            {\cf17 static} {\cf17 function} (ReflectionProperty $property) use ($filter): {\cf18 bool} \{\par
                {\cf19 return} ({\cf18 bool}) ($filter & $property->getModifiers());\par
            \},\par
        );\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getProperty({\cf18 string} $name): ?ReflectionProperty\par
    \{\par
        $properties = $this->getProperties();\par
\par
        {\cf19 if} (! isset($properties[$name])) \{\par
            {\cf19 return} {\cf17 null};\par
        \}\par
\par
        {\cf19 return} $properties[$name];\par
    \}\par
\par
    {\cf17 public} {\cf17 function} hasProperty({\cf18 string} $name): bool\par
    \{\par
        {\cf19 return} $this->getProperty($name) !== {\cf17 null};\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getDefaultProperties(): array\par
    \{\par
        {\cf19 return} array_map(\par
            {\cf17 static} {\cf17 function} (ReflectionProperty $property) \{\par
                {\cf19 return} $property->getDefaultValue();\par
            \},\par
            array_filter($this->getProperties(), {\cf17 static} {\cf17 function} (ReflectionProperty $property): {\cf18 bool} \{\par
                {\cf19 return} $property->isDefault();\par
            \}),\par
        );\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getFileName(): ?string\par
    \{\par
        {\cf19 return} $this->locatedSource->getFileName();\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getLocatedSource(): LocatedSource\par
    \{\par
        {\cf19 return} $this->locatedSource;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getStartLine(): int\par
    \{\par
        {\cf19 return} $this->node->getStartLine();\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getEndLine(): int\par
    \{\par
        {\cf19 return} $this->node->getEndLine();\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getStartColumn(): int\par
    \{\par
        {\cf19 return} CalculateReflectionColumn::getStartColumn($this->locatedSource->getSource(), $this->node);\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getEndColumn(): int\par
    \{\par
        {\cf19 return} CalculateReflectionColumn::getEndColumn($this->locatedSource->getSource(), $this->node);\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getParentClass(): ?ReflectionClass\par
    \{\par
        {\cf19 if} (! ($this->node instanceof ClassNode) || $this->node->extends === {\cf17 null}) \{\par
            {\cf19 return} {\cf17 null};\par
        \}\par
\par
        {\cf19 if} ($this->cachedParentClass === {\cf17 null}) \{\par
            $parent = $this->reflector->reflect($this->node->extends->toString());\par
            {\cf20 // @TODO use actual `ClassReflector` or `FunctionReflector`?}\par
            assert($parent instanceof {\cf17 self});\par
\par
            $this->cachedParentClass = $parent;\par
        \}\par
\par
        {\cf19 if} ($this->cachedParentClass->isInterface() || $this->cachedParentClass->isTrait()) \{\par
            {\cf19 throw} NotAClassReflection::fromReflectionClass($this->cachedParentClass);\par
        \}\par
\par
        {\cf19 return} $this->cachedParentClass;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getParentClassNames(): array\par
    \{\par
        {\cf19 return} array_map({\cf17 static} {\cf17 function} ({\cf17 self} $parentClass): {\cf18 string} \{\par
            {\cf19 return} $parentClass->getName();\par
        \}, array_slice(array_reverse($this->getInheritanceClassHierarchy()), 1));\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getDocComment(): string\par
    \{\par
        {\cf19 return} GetLastDocComment::forNode($this->node);\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isAnonymous(): bool\par
    \{\par
        {\cf19 return} $this->node->name === {\cf17 null};\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isInternal(): bool\par
    \{\par
        {\cf19 return} $this->locatedSource->isInternal();\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isUserDefined(): bool\par
    \{\par
        {\cf19 return} ! $this->isInternal();\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isAbstract(): bool\par
    \{\par
        {\cf19 return} $this->node instanceof ClassNode && $this->node->isAbstract();\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isFinal(): bool\par
    \{\par
        {\cf19 return} $this->node instanceof ClassNode && $this->node->isFinal();\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getModifiers(): int\par
    \{\par
        $val  = 0;\par
        $val += $this->isAbstract() ? CoreReflectionClass::IS_EXPLICIT_ABSTRACT : 0;\par
        $val += $this->isFinal() ? CoreReflectionClass::IS_FINAL : 0;\par
\par
        {\cf19 return} $val;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isTrait(): bool\par
    \{\par
        {\cf19 return} $this->node instanceof TraitNode;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isInterface(): bool\par
    \{\par
        {\cf19 return} $this->node instanceof InterfaceNode;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getTraits(): array\par
    \{\par
        {\cf19 return} array_map(\par
            {\cf17 function} (Node\\Name $importedTrait): ReflectionClass \{\par
                {\cf19 return} $this->reflectClassForNamedNode($importedTrait);\par
            \},\par
            array_merge(\par
                [],\par
                ...array_map(\par
                    {\cf17 static} {\cf17 function} (TraitUse $traitUse): array \{\par
                        {\cf19 return} $traitUse->traits;\par
                    \},\par
                    array_filter($this->node->stmts, {\cf17 static} function (Node $node): {\cf18 bool} \{\par
                        {\cf19 return} $node instanceof TraitUse;\par
                    \}),\par
                ),\par
            ),\par
        );\par
    \}\par
\par
    {\cf17 private} {\cf17 function} reflectClassForNamedNode(Node\\Name $node): self\par
    \{\par
        {\cf20 // @TODO use actual `ClassReflector` or `FunctionReflector`?}\par
        {\cf19 if} ($this->isAnonymous()) \{\par
            $class = ({\cf17 new} BetterReflection())->classReflector()->reflect($node->toString());\par
        \} {\cf19 else} \{\par
            $class = $this->reflector->reflect($node->toString());\par
            assert($class instanceof {\cf17 self});\par
        \}\par
\par
        {\cf19 return} $class;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getTraitNames(): array\par
    \{\par
        {\cf19 return} array_map(\par
            {\cf17 static} {\cf17 function} (ReflectionClass $trait): {\cf18 string} \{\par
                {\cf19 return} $trait->getName();\par
            \},\par
            $this->getTraits(),\par
        );\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getTraitAliases(): array\par
    \{\par
        $this->parseTraitUsages();\par
\par
        {\cf19 return} $this->cachedTraitAliases;\par
    \}\par
\par
    {\cf17 private} {\cf17 function} getTraitPrecedences(): array\par
    \{\par
        $this->parseTraitUsages();\par
\par
        {\cf19 return} $this->cachedTraitPrecedences;\par
    \}\par
\par
    {\cf17 private} {\cf17 function} parseTraitUsages(): void\par
    \{\par
        {\cf19 if} ($this->cachedTraitAliases !== {\cf17 null} && $this->cachedTraitPrecedences !== {\cf17 null}) \{\par
            {\cf19 return};\par
        \}\par
\par
        $traitUsages = array_filter($this->node->stmts, {\cf17 static} function (Node $node): {\cf18 bool} \{\par
            {\cf19 return} $node instanceof TraitUse;\par
        \});\par
\par
        $this->cachedTraitAliases     = [];\par
        $this->cachedTraitPrecedences = [];\par
\par
        {\cf19 foreach} ($traitUsages as $traitUsage) \{\par
            $traitNames  = $traitUsage->traits;\par
            $adaptations = $traitUsage->adaptations;\par
\par
            {\cf19 foreach} ($adaptations as $adaptation) \{\par
                $usedTrait = $adaptation->trait;\par
                {\cf19 if} ($usedTrait === {\cf17 null}) \{\par
                    $usedTrait = $traitNames[0];\par
                \}\par
\par
                {\cf19 if} ($adaptation instanceof Node\\Stmt\\TraitUseAdaptation\\Alias && $adaptation->newName) \{\par
                    $this->cachedTraitAliases[$adaptation->newName->name] = $this->methodHash($usedTrait->toString(), $adaptation->method->toString());\par
                    {\cf19 continue};\par
                \}\par
\par
                {\cf19 if} (! $adaptation instanceof Node\\Stmt\\TraitUseAdaptation\\Precedence || ! $adaptation->insteadof) \{\par
                    {\cf19 continue};\par
                \}\par
\par
                {\cf19 foreach} ($adaptation->insteadof as $insteadof) \{\par
                    $adaptationNameHash = $this->methodHash($insteadof->toString(), $adaptation->method->toString());\par
                    $originalNameHash   = $this->methodHash($usedTrait->toString(), $adaptation->method->toString());\par
\par
                    $this->cachedTraitPrecedences[$adaptationNameHash] = $originalNameHash;\par
                \}\par
            \}\par
        \}\par
    \}\par
\par
    {\cf17 private} {\cf17 function} methodHash({\cf18 string} $className, {\cf18 string} $methodName): string\par
    \{\par
        {\cf19 return} sprintf(\par
            {\cf22 '%s::%s'},\par
            $className,\par
            $methodName,\par
        );\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getInterfaces(): array\par
    \{\par
        {\cf19 return} array_merge(...array_map(\par
            {\cf17 static} {\cf17 function} ({\cf17 self} $reflectionClass): array \{\par
                {\cf19 return} $reflectionClass->getCurrentClassImplementedInterfacesIndexedByName();\par
            \},\par
            $this->getInheritanceClassHierarchy(),\par
        ));\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getImmediateInterfaces(): array\par
    \{\par
        {\cf19 if} ($this->isTrait()) \{\par
            {\cf19 return} [];\par
        \}\par
\par
        assert($this->node instanceof ClassNode || $this->node instanceof InterfaceNode);\par
\par
        $nodes = $this->node instanceof InterfaceNode ? $this->node->extends : $this->node->implements;\par
\par
        {\cf19 return} array_combine(\par
            array_map(\par
                {\cf17 static} {\cf17 function} (Node\\Name $interfaceName): {\cf18 string} \{\par
                    {\cf19 return} $interfaceName->toString();\par
                \},\par
                $nodes,\par
            ),\par
            array_map(\par
                {\cf17 function} (Node\\Name $interfaceName): ReflectionClass \{\par
                    {\cf19 return} $this->reflectClassForNamedNode($interfaceName);\par
                \},\par
                $nodes,\par
            ),\par
        );\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getInterfaceNames(): array\par
    \{\par
        {\cf19 return} array_values(array_map(\par
            {\cf17 static} {\cf17 function} ({\cf17 self} $interface): {\cf18 string} \{\par
                {\cf19 return} $interface->getName();\par
            \},\par
            $this->getInterfaces(),\par
        ));\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isInstance({\cf18 object} $object): bool\par
    \{\par
        $className = $this->getName();\par
\par
        {\cf20 // note: since $object was loaded, we can safely assume that $className is available in the current}\par
        {\cf20 //       php script execution context}\par
        {\cf19 return} $object instanceof $className;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isSubclassOf({\cf18 string} $className): bool\par
    \{\par
        {\cf19 return} in_array(\par
            ltrim($className, {\cf23 '\\\\'}),\par
            array_map(\par
                {\cf17 static} {\cf17 function} ({\cf17 self} $reflectionClass): {\cf18 string} \{\par
                    {\cf19 return} $reflectionClass->getName();\par
                \},\par
                array_slice(array_reverse($this->getInheritanceClassHierarchy()), 1),\par
            ),\par
            {\cf17 true},\par
        );\par
    \}\par
\par
    {\cf17 public} {\cf17 function} implementsInterface({\cf18 string} $interfaceName): bool\par
    \{\par
        {\cf19 return} in_array(ltrim($interfaceName, {\cf23 '\\\\'}), $this->getInterfaceNames(), {\cf17 true});\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isInstantiable(): bool\par
    \{\par
        {\cf20 // @TODO doesn't consider internal non-instantiable classes yet.}\par
\par
        {\cf19 if} ($this->isAbstract()) \{\par
            {\cf19 return} {\cf17 false};\par
        \}\par
\par
        {\cf19 if} ($this->isInterface()) \{\par
            {\cf19 return} {\cf17 false};\par
        \}\par
\par
        {\cf19 if} ($this->isTrait()) \{\par
            {\cf19 return} {\cf17 false};\par
        \}\par
\par
        {\cf19 try} \{\par
            {\cf19 return} $this->getConstructor()->isPublic();\par
        \} {\cf19 catch} (OutOfBoundsException $e) \{\par
            {\cf19 return} {\cf17 true};\par
        \}\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isCloneable(): bool\par
    \{\par
        {\cf19 if} (! $this->isInstantiable()) \{\par
            {\cf19 return} {\cf17 false};\par
        \}\par
\par
        {\cf19 if} (! $this->hasMethod({\cf22 '__clone'})) \{\par
            {\cf19 return} {\cf17 true};\par
        \}\par
\par
        {\cf19 return} $this->getMethod({\cf22 '__clone'})->isPublic();\par
    \}\par
\par
    {\cf17 public} {\cf17 function} isIterateable(): bool\par
    \{\par
        {\cf19 return} $this->isInstantiable() && $this->implementsInterface(Traversable::class);\par
    \}\par
\par
    {\cf17 private} {\cf17 function} getCurrentClassImplementedInterfacesIndexedByName(): array\par
    \{\par
        $node = $this->node;\par
\par
        {\cf19 if} ($node instanceof ClassNode) \{\par
            {\cf19 return} array_merge(\par
                [],\par
                ...array_map(\par
                    {\cf17 function} (Node\\Name $interfaceName): array \{\par
                        {\cf19 return} $this\par
                            ->reflectClassForNamedNode($interfaceName)\par
                            ->getInterfacesHierarchy();\par
                    \},\par
                    $node->implements,\par
                ),\par
            );\par
        \}\par
\par
        {\cf20 // assumption: first key is the current interface}\par
        {\cf19 return} $this->isInterface()\par
            ? array_slice($this->getInterfacesHierarchy(), 1)\par
            : [];\par
    \}\par
\par
    {\cf17 private} {\cf17 function} getInheritanceClassHierarchy(): array\par
    \{\par
        $parentClass = $this->getParentClass();\par
\par
        {\cf19 return} $parentClass\par
            ? array_merge($parentClass->getInheritanceClassHierarchy(), [$this])\par
            : [$this];\par
    \}\par
\par
    {\cf17 private} {\cf17 function} getInterfacesHierarchy(): array\par
    \{\par
        {\cf19 if} (! $this->isInterface()) \{\par
            {\cf19 throw} NotAnInterfaceReflection::fromReflectionClass($this);\par
        \}\par
\par
        $node = $this->node;\par
        assert($node instanceof InterfaceNode);\par
\par
        {\cf19 return} array_merge(\par
            [$this->getName() => $this],\par
            ...array_map(\par
                {\cf17 function} (Node\\Name $interfaceName): array \{\par
                    {\cf19 return} $this\par
                        ->reflectClassForNamedNode($interfaceName)\par
                        ->getInterfacesHierarchy();\par
                \},\par
                $node->extends,\par
            ),\par
        );\par
    \}\par
\par
    {\cf17 public} {\cf17 function} __clone()\par
    \{\par
        {\cf19 throw} Uncloneable::fromClass(static::class);\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getStaticPropertyValue({\cf18 string} $propertyName)\par
    \{\par
        $property = $this->getProperty($propertyName);\par
\par
        {\cf19 if} (! $property || ! $property->isStatic()) \{\par
            {\cf19 throw} PropertyDoesNotExist::fromName($propertyName);\par
        \}\par
\par
        {\cf19 return} $property->getValue();\par
    \}\par
\par
    {\cf17 public} {\cf17 function} setStaticPropertyValue({\cf18 string} $propertyName, $value): void\par
    \{\par
        $property = $this->getProperty($propertyName);\par
\par
        {\cf19 if} (! $property || ! $property->isStatic()) \{\par
            {\cf19 throw} PropertyDoesNotExist::fromName($propertyName);\par
        \}\par
\par
        $property->setValue($value);\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getStaticProperties(): array\par
    \{\par
        $staticProperties = [];\par
\par
        {\cf19 foreach} ($this->getProperties() as $property) \{\par
            {\cf19 if} (! $property->isStatic()) \{\par
                {\cf19 continue};\par
            \}\par
\par
            $staticProperties[$property->getName()] = $property->getValue();\par
        \}\par
\par
        {\cf19 return} $staticProperties;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getAst(): ClassLikeNode\par
    \{\par
        {\cf19 return} $this->node;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} getDeclaringNamespaceAst(): ?Namespace_\par
    \{\par
        {\cf19 return} $this->declaringNamespace;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} setFinal({\cf18 bool} $isFinal): void\par
    \{\par
        {\cf19 if} (! $this->node instanceof ClassNode) \{\par
            {\cf19 throw} NotAClassReflection::fromReflectionClass($this);\par
        \}\par
\par
        {\cf19 if} ($isFinal === {\cf17 true}) \{\par
            $this->node->flags |= ClassNode::MODIFIER_FINAL;\par
\par
            {\cf19 return};\par
        \}\par
\par
        $this->node->flags &= ~ClassNode::MODIFIER_FINAL;\par
    \}\par
\par
    {\cf17 public} {\cf17 function} removeMethod({\cf18 string} $methodName): bool\par
    \{\par
        $lowerName = strtolower($methodName);\par
        {\cf19 foreach} ($this->node->stmts as $key => $stmt) \{\par
            {\cf19 if} ($stmt instanceof ClassMethod && $lowerName === $stmt->name->toLowerString()) \{\par
                unset($this->node->stmts[$key]);\par
                $this->cachedMethods = {\cf17 null};\par
\par
                {\cf19 return} {\cf17 true};\par
            \}\par
        \}\par
\par
        {\cf19 return} {\cf17 false};\par
    \}\par
\par
    {\cf17 public} {\cf17 function} addMethod({\cf18 string} $methodName): void\par
    \{\par
        $this->node->stmts[] = {\cf17 new} ClassMethod($methodName);\par
        $this->cachedMethods = {\cf17 null};\par
    \}\par
\par
    {\cf17 public} {\cf17 function} addProperty(\par
        {\cf18 string} $propertyName,\par
        {\cf18 int} $visibility = CoreReflectionProperty::IS_PUBLIC,\par
        {\cf18 bool} $static = {\cf17 false}\par
    ): void \{\par
        $type = 0;\par
        {\cf19 switch} ($visibility) \{\par
            {\cf19 case} CoreReflectionProperty::IS_PRIVATE:\par
                $type |= ClassNode::MODIFIER_PRIVATE;\par
                {\cf19 break};\par
            {\cf19 case} CoreReflectionProperty::IS_PROTECTED:\par
                $type |= ClassNode::MODIFIER_PROTECTED;\par
                {\cf19 break};\par
            {\cf19 default}:\par
                $type |= ClassNode::MODIFIER_PUBLIC;\par
                {\cf19 break};\par
        \}\par
\par
        {\cf19 if} ($static) \{\par
            $type |= ClassNode::MODIFIER_STATIC;\par
        \}\par
\par
        $this->node->stmts[]             = {\cf17 new} PropertyNode($type, [{\cf17 new} Node\\Stmt\\PropertyProperty($propertyName)]);\par
        $this->cachedProperties          = {\cf17 null};\par
        $this->cachedImmediateProperties = {\cf17 null};\par
    \}\par
\par
    {\cf17 public} {\cf17 function} removeProperty({\cf18 string} $propertyName): bool\par
    \{\par
        $lowerName = strtolower($propertyName);\par
\par
        {\cf19 foreach} ($this->node->stmts as $key => $stmt) \{\par
            {\cf19 if} (! ($stmt instanceof PropertyNode)) \{\par
                {\cf19 continue};\par
            \}\par
\par
            $propertyNames = array_map({\cf17 static} {\cf17 function} (Node\\Stmt\\PropertyProperty $propertyProperty): {\cf18 string} \{\par
                {\cf19 return} $propertyProperty->name->toLowerString();\par
            \}, $stmt->props);\par
\par
            {\cf19 if} (in_array($lowerName, $propertyNames, {\cf17 true})) \{\par
                $this->cachedProperties          = {\cf17 null};\par
                $this->cachedImmediateProperties = {\cf17 null};\par
                unset($this->node->stmts[$key]);\par
\par
                {\cf19 return} {\cf17 true};\par
            \}\par
        \}\par
\par
        {\cf19 return} {\cf17 false};\par
    \}\par
\}\par
\par}
 \par
}}